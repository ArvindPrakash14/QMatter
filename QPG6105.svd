<?xml version="1.0" encoding="utf-8"?>

<!-- Start of SVD definition. -->

<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="addressmap.svd" >
  <vendor>Qorvo Inc</vendor>                                      <!-- device vendor name -->
  <vendorID>QORVO</vendorID>                                      <!-- device vendor short name -->
  <name>Qorvo_SVD</name>                                          <!-- name of part-->
  <series>ARMCM4</series>                                         <!-- device series the device belongs to -->
  <version>1.0</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>ARM CM4 device. </description>
  <licenseText>                                                   <!-- this license text will appear in header file. \n force line breaks -->
    </licenseText>

  <!-- <cpu>
    <name>CM4</name>
    <revision>r1p0</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <nvicPrioBits>3</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu> -->

  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->

  <!-- default settings implicitly inherited by subsequent sections -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->

  <peripherals>
    <peripheral>
      <name>IOB</name>
      <baseAddress>0x40000700</baseAddress>
      <registers>
        <register>
          <name>IOB_0X00000000</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DBG0_SEL</name>
              <bitRange>[7:0]</bitRange>
              <description>selects internal signal to see on dbg0</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_0X00000001</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DBG1_SEL</name>
              <bitRange>[7:0]</bitRange>
              <description>selects internal signal to see on dbg1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_0X00000002</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DBG2_SEL</name>
              <bitRange>[7:0]</bitRange>
              <description>selects internal signal to see on dbg2</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_0X00000003</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DBG3_SEL</name>
              <bitRange>[7:0]</bitRange>
              <description>selects internal signal to see on dbg3</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_0X00000004</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DBG4_SEL</name>
              <bitRange>[7:0]</bitRange>
              <description>selects internal signal to see on dbg4</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_0X00000005</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DBG5_SEL</name>
              <bitRange>[7:0]</bitRange>
              <description>selects internal signal to see on dbg5</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_A_0[0]</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_0_CFG</name>
              <bitRange>[1:0]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_1_CFG</name>
              <bitRange>[3:2]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_2_CFG</name>
              <bitRange>[5:4]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_3_CFG</name>
              <bitRange>[7:6]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_A_0[1]</name>
          <addressOffset>0x0009</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_4_CFG</name>
              <bitRange>[1:0]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_5_CFG</name>
              <bitRange>[3:2]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_6_CFG</name>
              <bitRange>[5:4]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_7_CFG</name>
              <bitRange>[7:6]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_A_0[2]</name>
          <addressOffset>0x000A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_8_CFG</name>
              <bitRange>[1:0]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_9_CFG</name>
              <bitRange>[3:2]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_10_CFG</name>
              <bitRange>[5:4]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_11_CFG</name>
              <bitRange>[7:6]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_A_0[3]</name>
          <addressOffset>0x000B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_12_CFG</name>
              <bitRange>[1:0]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_13_CFG</name>
              <bitRange>[3:2]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_14_CFG</name>
              <bitRange>[5:4]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_15_CFG</name>
              <bitRange>[7:6]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_A_0[4]</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_16_CFG</name>
              <bitRange>[1:0]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_17_CFG</name>
              <bitRange>[3:2]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_18_CFG</name>
              <bitRange>[5:4]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_A_0[5]</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_21_CFG</name>
              <bitRange>[3:2]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
            <field>
              <name>GPIO_22_CFG</name>
              <bitRange>[5:4]</bitRange>
              <description>pull up, pull down, buskeeper configuration</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_B[0]</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_0_3_DRIVE_STRENGTH</name>
              <bitRange>[1:0]</bitRange>
              <description>drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA</description>
            </field>
            <field>
              <name>GPIO_0_3_SCHMITT_TRIGGER</name>
              <bitRange>[2:2]</bitRange>
              <description>Schmitt trigger enable</description>
            </field>
            <field>
              <name>GPIO_4_7_DRIVE_STRENGTH</name>
              <bitRange>[4:3]</bitRange>
              <description>drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA</description>
            </field>
            <field>
              <name>GPIO_4_7_SCHMITT_TRIGGER</name>
              <bitRange>[5:5]</bitRange>
              <description>Schmitt trigger enable</description>
            </field>
            <field>
              <name>GPIO_8_11_DRIVE_STRENGTH</name>
              <bitRange>[7:6]</bitRange>
              <description>drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_B[1]</name>
          <addressOffset>0x0011</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_8_11_SCHMITT_TRIGGER</name>
              <bitRange>[0:0]</bitRange>
              <description>Schmitt trigger enable</description>
            </field>
            <field>
              <name>GPIO_12_15_DRIVE_STRENGTH</name>
              <bitRange>[2:1]</bitRange>
              <description>drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA</description>
            </field>
            <field>
              <name>GPIO_12_15_SCHMITT_TRIGGER</name>
              <bitRange>[3:3]</bitRange>
              <description>Schmitt trigger enable</description>
            </field>
            <field>
              <name>GPIO_16_19_DRIVE_STRENGTH</name>
              <bitRange>[5:4]</bitRange>
              <description>drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA</description>
            </field>
            <field>
              <name>GPIO_16_19_SCHMITT_TRIGGER</name>
              <bitRange>[6:6]</bitRange>
              <description>Schmitt trigger enable</description>
            </field>
            <field>
              <name>GPIO_20_23_SCHMITT_TRIGGER</name>
              <bitRange>[7:7]</bitRange>
              <description>Schmitt trigger enable</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_B[2]</name>
          <addressOffset>0x0012</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_20_23_DRIVE_STRENGTH</name>
              <bitRange>[1:0]</bitRange>
              <description>drive strength 00 = 4.5mA, 01 = 9mA, 10 = 13.5mA, 11 = 18mA</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_C[0]</name>
          <addressOffset>0x0014</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_0_PULSECFG</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_1_PULSECFG</name>
              <bitRange>[1:1]</bitRange>
              <description>Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_2_PULSECFG</name>
              <bitRange>[2:2]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_3_PULSECFG</name>
              <bitRange>[3:3]</bitRange>
              <description>Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_4_PULSECFG</name>
              <bitRange>[4:4]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_5_PULSECFG</name>
              <bitRange>[5:5]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_6_PULSECFG</name>
              <bitRange>[6:6]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_7_PULSECFG</name>
              <bitRange>[7:7]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_C[1]</name>
          <addressOffset>0x0015</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_8_PULSECFG</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_9_PULSECFG</name>
              <bitRange>[1:1]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_10_PULSECFG</name>
              <bitRange>[2:2]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_11_PULSECFG</name>
              <bitRange>[3:3]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_12_PULSECFG</name>
              <bitRange>[4:4]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_13_PULSECFG</name>
              <bitRange>[5:5]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_14_PULSECFG</name>
              <bitRange>[6:6]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_15_PULSECFG</name>
              <bitRange>[7:7]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_PIN_CONFIG_C[2]</name>
          <addressOffset>0x0016</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_16_PULSECFG</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_17_PULSECFG</name>
              <bitRange>[1:1]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_18_PULSECFG</name>
              <bitRange>[2:2]</bitRange>
              <description>Enables a strong driver in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the strong driver is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_21_PULSECFG</name>
              <bitRange>[3:3]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
            <field>
              <name>GPIO_22_PULSECFG</name>
              <bitRange>[4:4]</bitRange>
              <description>Enables a pullup in the iocell that can be activated in a duty cycled way (also during sleep). The signal activating the pull up is generated in the pmud (setting gpio_pu_pulse_period)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_0_ALTERNATE_CFG</name>
          <addressOffset>0x0017</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_0_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_0_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_1_ALTERNATE_CFG</name>
          <addressOffset>0x0018</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_1_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_1_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_2_ALTERNATE_CFG</name>
          <addressOffset>0x0019</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_2_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_2_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_3_ALTERNATE_CFG</name>
          <addressOffset>0x001A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_3_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_3_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_4_ALTERNATE_CFG</name>
          <addressOffset>0x001B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_4_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_4_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_5_ALTERNATE_CFG</name>
          <addressOffset>0x001C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_5_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_5_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_6_ALTERNATE_CFG</name>
          <addressOffset>0x001D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_6_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_6_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_7_ALTERNATE_CFG</name>
          <addressOffset>0x001E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_7_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_7_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_8_ALTERNATE_CFG</name>
          <addressOffset>0x001F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_8_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_8_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_9_ALTERNATE_CFG</name>
          <addressOffset>0x0020</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_9_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_9_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_10_ALTERNATE_CFG</name>
          <addressOffset>0x0021</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_10_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_10_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_11_ALTERNATE_CFG</name>
          <addressOffset>0x0022</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_11_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_11_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_12_ALTERNATE_CFG</name>
          <addressOffset>0x0023</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_12_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_12_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_13_ALTERNATE_CFG</name>
          <addressOffset>0x0024</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_13_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_13_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_14_ALTERNATE_CFG</name>
          <addressOffset>0x0025</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_14_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_14_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_15_ALTERNATE_CFG</name>
          <addressOffset>0x0026</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_15_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_15_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_16_ALTERNATE_CFG</name>
          <addressOffset>0x0027</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_16_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_16_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_17_ALTERNATE_CFG</name>
          <addressOffset>0x0028</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_17_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_17_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_18_ALTERNATE_CFG</name>
          <addressOffset>0x0029</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_18_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_18_ALTERNATE</name>
              <bitRange>[5:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_19_ALTERNATE_CFG</name>
          <addressOffset>0x002A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_19_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_19_ALTERNATE</name>
              <bitRange>[3:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_20_ALTERNATE_CFG</name>
          <addressOffset>0x002B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_20_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_20_ALTERNATE</name>
              <bitRange>[2:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_21_ALTERNATE_CFG</name>
          <addressOffset>0x002C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_21_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_21_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_22_ALTERNATE_CFG</name>
          <addressOffset>0x002D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_22_ALTERNATE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO_22_ALTERNATE</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_INPUT_BUFFER_ENABLE</name>
          <addressOffset>0x002E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_17_INPUT_BUFFER_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>enables/disables the input buffer on gpio 17. Disabling the buffer supplies isolation for when the pad is used for something else.</description>
            </field>
            <field>
              <name>GPIO_18_INPUT_BUFFER_ENABLE</name>
              <bitRange>[1:1]</bitRange>
              <description>enables/disables the input buffer on gpio 18. Disabling the buffer supplies isolation for when the pad is used for something else.</description>
            </field>
            <field>
              <name>GPIO_19_INPUT_BUFFER_ENABLE</name>
              <bitRange>[2:2]</bitRange>
              <description>enables/disables the input buffer on gpio 19. Disabling the buffer supplies isolation for when the pad is used for something else.</description>
            </field>
            <field>
              <name>GPIO_20_INPUT_BUFFER_ENABLE</name>
              <bitRange>[3:3]</bitRange>
              <description>enables/disables the input buffer on gpio 20. Disabling the buffer supplies isolation for when the pad is used for something else.</description>
            </field>
            <field>
              <name>GPIO_21_INPUT_BUFFER_ENABLE</name>
              <bitRange>[4:4]</bitRange>
              <description>enables/disables the input buffer on gpio 21. Disabling the buffer supplies isolation for when the pad is used for something else.</description>
            </field>
            <field>
              <name>GPIO_22_INPUT_BUFFER_ENABLE</name>
              <bitRange>[5:5]</bitRange>
              <description>enables/disables the input buffer on gpio 22. Disabling the buffer supplies isolation for when the pad is used for something else.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_GPIO_MISC_CONFIG</name>
          <addressOffset>0x002F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_IDDQ</name>
              <bitRange>[0:0]</bitRange>
              <description>controls the iddq input of the gpios</description>
            </field>
            <field>
              <name>IR_LED_ENABLE</name>
              <bitRange>[1:1]</bitRange>
              <description>Enables a high drive (sink) on ir pad</description>
            </field>
            <field>
              <name>IR_LED_SLOWDOWN</name>
              <bitRange>[2:2]</bitRange>
              <description>Reduces drive-strength to high drive IR pad</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_VILVIH_VOLVOH_SELECT</name>
          <addressOffset>0x0030</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>VILVIH_40_PIN</name>
              <bitRange>[0:0]</bitRange>
              <description>Select 40 pin vilvih mode</description>
            </field>
            <field>
              <name>VOLVOH_40_PIN</name>
              <bitRange>[1:1]</bitRange>
              <description>Select 40 pin volvoh mode</description>
            </field>
            <field>
              <name>EXT_FLASH_RMA_0_ENABLE</name>
              <bitRange>[2:2]</bitRange>
              <description>Enables the rma interface for type 0 external flash</description>
            </field>
            <field>
              <name>EXT_FLASH_RMA_1_ENABLE</name>
              <bitRange>[3:3]</bitRange>
              <description>Enables the rma interface for type 1 external flash</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IOB_0X00000031</name>
          <addressOffset>0x0031</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>DEBUG_STATUS</name>
              <bitRange>[5:0]</bitRange>
              <description>Reflects the values on the debug bus</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>ES</name>
      <baseAddress>0x40000900</baseAddress>
      <registers>
        <register>
          <name>ES_TIME_REFERENCE_SETTING</name>
          <addressOffset>0x0000</addressOffset>
          <size>16</size>
          <resetValue>0x00000006</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE_SAMPLE_CONVERSION_BY_GPIO_EXTERN</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable Sample Conversion By GPIO Extern</description>
            </field>
            <field>
              <name>CLK_OSB_STABLE_ON_FALLING_EDGE</name>
              <bitRange>[1:1]</bitRange>
              <description>Select what edge of oscillator benchmark clk is jitter free</description>
            </field>
            <field>
              <name>GRAY_COUNTER_STABLE_ON_FALLING_EDGE</name>
              <bitRange>[2:2]</bitRange>
              <description>Select on which edge of standby clock the gray counter is stable</description>
            </field>
            <field>
              <name>DISABLE_AUTOMATIC_REFERENCE_POINT_UPDATE</name>
              <bitRange>[3:3]</bitRange>
              <description>Disable Automatic Reference Point Update</description>
            </field>
            <field>
              <name>RECONVERSION_ON_UPDATES</name>
              <bitRange>[4:4]</bitRange>
              <description>Reconversion on updates</description>
            </field>
            <field>
              <name>DISABLE_EXTRAPOLATION</name>
              <bitRange>[5:5]</bitRange>
              <description>Disable Extrapolation</description>
            </field>
            <field>
              <name>DISABLE_CONVERSION</name>
              <bitRange>[6:6]</bitRange>
              <description>Disable Conversion</description>
            </field>
            <field>
              <name>FAST_SYNC_ON_START</name>
              <bitRange>[7:7]</bitRange>
              <description>Fast Sync On Start</description>
            </field>
            <field>
              <name>ENABLE_OSCILLATOR_BENCHMARK</name>
              <bitRange>[8:8]</bitRange>
              <description>Enable Oscillator Benchmark</description>
            </field>
            <field>
              <name>AUTO_TRIGGER_OSCILLATOR_BENCHMARK_WHEN_NOT_VALID</name>
              <bitRange>[9:9]</bitRange>
              <description>Auto trigger oscillator benchmark when oscillator benchmark is not valid</description>
            </field>
            <field>
              <name>KEEP_AWAKE_DURING_OSCILLATOR_BENCHMARK_MEASUREMENT</name>
              <bitRange>[10:10]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>LOCK_OSCILLATOR_BENCHMARK</name>
              <bitRange>[11:11]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>OSCILLATOR_BENCHMARK_CLK_SRC</name>
              <bitRange>[14:12]</bitRange>
              <description>determines what clock to use for the oscillator benchmark test</description>
            </field>
            <field>
              <name>ONLY_CONVERT_WHEN_NEEDED</name>
              <bitRange>[15:15]</bitRange>
              <description>only convert when needed, automatically disabling the conversion, only enable when symbol counter is not initialized or when a calibration (e.g. realignment) is to be executed</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000002</name>
          <addressOffset>0x0002</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_LP_TICKS_THRESHOLD</name>
              <bitRange>[11:0]</bitRange>
              <description>The number of ticks (+1) of the low power oscillator that is used by the oscillator benchmark to measure the number of 32MHz ticks over</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000004</name>
          <addressOffset>0x0004</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_SUB_COUNTER_MIN</name>
              <bitRange>[11:0]</bitRange>
              <description>The minimum number of oscillator ticks expected during a 1 slow clock period</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000006</name>
          <addressOffset>0x0006</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_SUB_COUNTER_MAX</name>
              <bitRange>[11:0]</bitRange>
              <description>The maximum number of oscillator ticks expected during a 1 slow clock period</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_TIME_REFERENCE_STATE</name>
          <addressOffset>0x000A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>APPLY_EXTERNAL_SIMPLE_CALIBRATION_BUSY</name>
              <bitRange>[0:0]</bitRange>
              <description>Apply Simple Calibration Busy</description>
            </field>
            <field>
              <name>APPLY_EXTERNAL_ADVANCED_CALIBRATION_BUSY</name>
              <bitRange>[1:1]</bitRange>
              <description>Apply Advanced Calibration Busy</description>
            </field>
            <field>
              <name>APPLY_EXTERNAL_ZERO_CALIBRATION_BUSY</name>
              <bitRange>[2:2]</bitRange>
              <description>Apply Zero Calibration Busy</description>
            </field>
            <field>
              <name>SYMBOL_COUNTER_UPDATED_SINCE_LAST_CALIBRATION</name>
              <bitRange>[3:3]</bitRange>
              <description>Symbol Counter Updated Since Last Calibration</description>
            </field>
            <field>
              <name>RECONVERSION_BUSY</name>
              <bitRange>[4:4]</bitRange>
              <description>Reconversion busy</description>
            </field>
            <field>
              <name>INIT_TIME_REFERENCE_BUSY</name>
              <bitRange>[5:5]</bitRange>
              <description>Init Event Scheduler Busy</description>
            </field>
            <field>
              <name>FAST_SYNC_BUSY</name>
              <bitRange>[6:6]</bitRange>
              <description>Fast Sync Busy</description>
            </field>
            <field>
              <name>APPLY_EXTERNAL_REALIGNMENT_CALIBRATION_BUSY</name>
              <bitRange>[7:7]</bitRange>
              <description>Apply Realignment Calibration Bus</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_TIME_REFERENCE_STATE2</name>
          <addressOffset>0x000B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_STATE</name>
              <bitRange>[1:0]</bitRange>
              <description>Oscillator benchmark state</description>
            </field>
            <field>
              <name>OSCILLATOR_BENCHMARK_RESULT_VALID</name>
              <bitRange>[2:2]</bitRange>
              <description>Oscillator benchmark result valid</description>
            </field>
            <field>
              <name>OSCILLATOR_BENCHMARK_SUB_COUNTER_TOO_LOW</name>
              <bitRange>[3:3]</bitRange>
              <description>status indicationg that during a measurement period, the number of ticks for 1 slow period was below the allowed min value</description>
            </field>
            <field>
              <name>OSCILLATOR_BENCHMARK_SUB_COUNTER_TOO_HIGH</name>
              <bitRange>[4:4]</bitRange>
              <description>status indicationg that during a measurement period, the number of ticks for 1 slow period was above the allowed max value</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000000C</name>
          <addressOffset>0x000C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>AUTO_SAMPLED_SYMBOL_COUNTER</name>
              <bitRange>[31:0]</bitRange>
              <description>Auto Sample Symbol Counter</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000010</name>
          <addressOffset>0x0010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>AUTO_SAMPLED_SYMBOL_COUNTER_ALTERNATE</name>
              <bitRange>[31:0]</bitRange>
              <description>Second auto samppled symbol counter, dedicated for second processor in the sybsystem</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000014</name>
          <addressOffset>0x0014</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BINARY_GRAY_COUNTER</name>
              <bitRange>[31:0]</bitRange>
              <description>Binary gray counter</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000018</name>
          <addressOffset>0x0018</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SYMBOL_COUNTER</name>
              <bitRange>[31:0]</bitRange>
              <description>Symbol counter</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000001C[0]</name>
          <addressOffset>0x001C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_COUNTER[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Number of 32MHz ticks seen by the oscillator benchmark</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000001C[1]</name>
          <addressOffset>0x001D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_COUNTER[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Number of 32MHz ticks seen by the oscillator benchmark</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000001C[2]</name>
          <addressOffset>0x001E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_COUNTER[2]</name>
              <bitRange>[7:0]</bitRange>
              <description>Number of 32MHz ticks seen by the oscillator benchmark</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000020</name>
          <addressOffset>0x0020</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_LP_TICKS_SEEN</name>
              <bitRange>[15:0]</bitRange>
              <description>Number of low power oscillator ticks seen by the oscillator benchmark</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000022</name>
          <addressOffset>0x0022</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>OSCILLATOR_BENCHMARK_SUB_COUNTER_RESULT</name>
              <bitRange>[11:0]</bitRange>
              <description>Number of low power oscillator ticks seen by the oscillator during 1 tick of the slow clock</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000024</name>
          <addressOffset>0x0024</addressOffset>
          <size>32</size>
          <resetValue>0x00001000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>STARTUP_SYMBOL_TIME</name>
              <bitRange>[31:0]</bitRange>
              <description>Startup symbol time. Resolution is 1 us</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000028</name>
          <addressOffset>0x0028</addressOffset>
          <size>32</size>
          <resetValue>0x00002000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LONG_STARTUP_SYMBOL_TIME</name>
              <bitRange>[31:0]</bitRange>
              <description>Startup long symbol time. Resolution is 1 us</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000002C</name>
          <addressOffset>0x002C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BINARY_GRAY_COUNTER_REFERENCE</name>
              <bitRange>[31:0]</bitRange>
              <description>Binary gray counter reference</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000030</name>
          <addressOffset>0x0030</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SYMBOL_COUNTER_REFERENCE</name>
              <bitRange>[31:0]</bitRange>
              <description>Symbol counter reference</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000034</name>
          <addressOffset>0x0034</addressOffset>
          <size>32</size>
          <resetValue>0x40000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CALIBRATION_FACTOR</name>
              <bitRange>[31:0]</bitRange>
              <description>Calibration factor</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000038</name>
          <addressOffset>0x0038</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PHASE_COMPENSATION</name>
              <bitRange>[31:0]</bitRange>
              <description>Phase compensation</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_TIME_REFERENCE_ENABLE_CLK_BY_UC</name>
          <addressOffset>0x003C</addressOffset>
          <size>8</size>
          <resetValue>0x00000003</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE_CLK_TIME_REFERENCE_BASE_A_BY_UC</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable clk time reference base a by uC</description>
            </field>
            <field>
              <name>ENABLE_CLK_TIME_REFERENCE_BASE_B_BY_UC</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable clk time reference base b by uC</description>
            </field>
            <field>
              <name>ENABLE_CLK_TIME_REFERENCE_IO_BY_UC</name>
              <bitRange>[2:2]</bitRange>
              <description>Enable clk time reference io by uC</description>
            </field>
            <field>
              <name>ENABLE_CLK_TIME_REFERENCE_OSCILLATOR_BENCHMARK_BY_UC</name>
              <bitRange>[3:3]</bitRange>
              <description>Enable clk time reference oscillator benchmark by uC</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_VALID_EVENTS</name>
          <addressOffset>0x003E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>VALID_EVENTS_0</name>
              <bitRange>[7:0]</bitRange>
              <description>Valid Events</description>
            </field>
            <field>
              <name>VALID_EVENTS_1</name>
              <bitRange>[15:8]</bitRange>
              <description>Valid Events</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000044</name>
          <addressOffset>0x0044</addressOffset>
          <size>16</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_TIME</name>
              <bitRange>[15:0]</bitRange>
              <description>Buffer time</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000046</name>
          <addressOffset>0x0046</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRIORITY_TIME</name>
              <bitRange>[15:0]</bitRange>
              <description>Priotiry time</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000048</name>
          <addressOffset>0x0048</addressOffset>
          <size>8</size>
          <resetValue>0x0000001F</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GUARD_TIME_SEL</name>
              <bitRange>[4:0]</bitRange>
              <description>Guard Time Selector</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_EVENT_HANDLER_SETTING</name>
          <addressOffset>0x0049</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>OVERWRITE_EXECUTION_TIME_ON_FINAL_EXECUTION</name>
              <bitRange>[0:0]</bitRange>
              <description>Overwrite execution time on final execution</description>
            </field>
            <field>
              <name>RELATIVE_EVENT_FREEZE_COUNTDOWN</name>
              <bitRange>[1:1]</bitRange>
              <description>Freeze relative event countdown</description>
            </field>
            <field>
              <name>EXTERNAL_EVENT_VALID</name>
              <bitRange>[2:2]</bitRange>
              <description>External event valid</description>
            </field>
            <field>
              <name>COMP_EVENT_VALID</name>
              <bitRange>[6:3]</bitRange>
              <description>Comparator event valid</description>
            </field>
            <field>
              <name>WAKEUP_ON_RF_EVENT_VALID</name>
              <bitRange>[7:7]</bitRange>
              <description>Wakeup on rf event valid</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000004A</name>
          <addressOffset>0x004A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>EXTERNAL_EVENT_TYPE_TO_BE_EXECUTED</name>
              <bitRange>[7:0]</bitRange>
              <description>External event type</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000004C</name>
          <addressOffset>0x004C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>EXTERNAL_EVENT_CUSTOM_DATA</name>
              <bitRange>[15:0]</bitRange>
              <description>Custom data of external event</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000004F</name>
          <addressOffset>0x004F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RELATIVE_EVENT_TYPE_TO_BE_EXECUTED</name>
              <bitRange>[7:0]</bitRange>
              <description>Relative event type</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000050</name>
          <addressOffset>0x0050</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RELATIVE_EVENT_CUSTOM_DATA</name>
              <bitRange>[15:0]</bitRange>
              <description>Custom data of relative event</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000052</name>
          <addressOffset>0x0052</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>COMP_EVENT_TYPE_TO_BE_EXECUTED</name>
              <bitRange>[7:0]</bitRange>
              <description>Comparator event type</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000054</name>
          <addressOffset>0x0054</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>COMP_EVENT_CUSTOM_DATA</name>
              <bitRange>[15:0]</bitRange>
              <description>Custom data of comparator event</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000056</name>
          <addressOffset>0x0056</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WAKEUP_ON_RF_EVENT_TYPE_TO_BE_EXECUTED</name>
              <bitRange>[7:0]</bitRange>
              <description>Wakeup_on_rf event type</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000058</name>
          <addressOffset>0x0058</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WAKEUP_ON_RF_EVENT_CUSTOM_DATA</name>
              <bitRange>[15:0]</bitRange>
              <description>Custom data of wakeup_on_rf event</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000005A</name>
          <addressOffset>0x005A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RELATIVE_EVENT_TIME_DELAY</name>
              <bitRange>[6:0]</bitRange>
              <description>Time delay (in multiples of 16 us) after which the event wil be executed</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_RELATIVE_EVENT_STATUS</name>
          <addressOffset>0x005B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>RELATIVE_EVENT_COUNTDOWN</name>
              <bitRange>[6:0]</bitRange>
              <description>Relative event count down</description>
            </field>
            <field>
              <name>RELATIVE_EVENT_PENDING</name>
              <bitRange>[7:7]</bitRange>
              <description>Relative event pending</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000005C</name>
          <addressOffset>0x005C</addressOffset>
          <size>16</size>
          <resetValue>0x000000FF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DITHER_SEED</name>
              <bitRange>[15:0]</bitRange>
              <description>Dither seed</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X0000005E</name>
          <addressOffset>0x005E</addressOffset>
          <size>8</size>
          <resetValue>0x00000007</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DITHER_BACKOFF_EXPONENT_MASK</name>
              <bitRange>[7:0]</bitRange>
              <description>Dither backoff exponent mask</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_EVENT_HANDLER_STATE</name>
          <addressOffset>0x005F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>CURRENT_EVENT_NUMBER</name>
              <bitRange>[3:0]</bitRange>
              <description>Current Event Number</description>
            </field>
            <field>
              <name>CURRENT_EVENT_PENDING</name>
              <bitRange>[4:4]</bitRange>
              <description>Current Event Pending</description>
            </field>
            <field>
              <name>CURRENT_EVENT_BEING_EXECUTED</name>
              <bitRange>[5:5]</bitRange>
              <description>Current Event Being Executed</description>
            </field>
            <field>
              <name>NEXT_EVENT_SEARCH_BUSY</name>
              <bitRange>[6:6]</bitRange>
              <description>Next Event Search Busy</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_EVENT_HANDLER_ENABLE_CLK_BY_UC</name>
          <addressOffset>0x0060</addressOffset>
          <size>8</size>
          <resetValue>0x00000007</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE_CLK_EVENT_HANDLER_BASE_A_BY_UC</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable clk event handler base a by uC</description>
            </field>
            <field>
              <name>ENABLE_CLK_EVENT_HANDLER_BASE_B_BY_UC</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable clk event handler base b by uC</description>
            </field>
            <field>
              <name>ENABLE_CLK_EVENT_HANDLER_EXTERNAL_EVENT_BY_UC</name>
              <bitRange>[2:2]</bitRange>
              <description>Enable clk event handler external event by uC</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_LAST_EXTERNAL_PIN_EVENT_STATE[0]</name>
          <addressOffset>0x0064</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>LAST_EXTERNAL_PIN_EVENT_STATE[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>event state of the external pins when last external pin event occurred</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_LAST_EXTERNAL_PIN_EVENT_STATE[1]</name>
          <addressOffset>0x0065</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>LAST_EXTERNAL_PIN_EVENT_STATE[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>event state of the external pins when last external pin event occurred</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_LAST_EXTERNAL_PIN_EVENT_STATE[2]</name>
          <addressOffset>0x0066</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>LAST_EXTERNAL_PIN_EVENT_STATE[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>event state of the external pins when last external pin event occurred</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x0068</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_EVENT_INTERRUPTS</name>
              <bitRange>[15:0]</bitRange>
              <description>Unmasked Event Interrupts</description>
            </field>
            <field>
              <name>UNMASKED_COMP_EVENT_INTERRUPTS</name>
              <bitRange>[19:16]</bitRange>
              <description>Unmasked comparator event interrupts</description>
            </field>
            <field>
              <name>UNMASKED_WAKEUP_ON_RF_EVENT_INTERRUPT</name>
              <bitRange>[20:20]</bitRange>
              <description>Unmasked wakeup_on_rf event interrupts</description>
            </field>
            <field>
              <name>UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT</name>
              <bitRange>[21:21]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT</name>
              <bitRange>[22:22]</bitRange>
              <description>Unmasked Oscillator Benchmark Done Interrupt</description>
            </field>
            <field>
              <name>UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT</name>
              <bitRange>[23:23]</bitRange>
              <description>Unmasked Oscillator Benchmark Done Interrupt</description>
            </field>
            <field>
              <name>UNMASKED_RELATIVE_EVENT_INTERRUPT</name>
              <bitRange>[24:24]</bitRange>
              <description>Unmasked Relative Event Interrupt</description>
            </field>
            <field>
              <name>UNMASKED_EXTERNAL_EVENT_INTERRUPT</name>
              <bitRange>[25:25]</bitRange>
              <description>Unmasked External Event Interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_RETENTION_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x0070</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RETENTION_UNMASKED_EVENT_INTERRUPTS</name>
              <bitRange>[15:0]</bitRange>
              <description>Retention unmasked event Interrupts</description>
            </field>
            <field>
              <name>RETENTION_UNMASKED_COMP_EVENT_INTERRUPTS</name>
              <bitRange>[19:16]</bitRange>
              <description>Retention unmasked Comp Event Interrupts</description>
            </field>
            <field>
              <name>RETENTION_UNMASKED_WAKEUP_ON_RF_EVENT_INTERRUPT</name>
              <bitRange>[20:20]</bitRange>
              <description>Retention unmasked wakeup_on_rf Event Interrupts</description>
            </field>
            <field>
              <name>RETENTION_UNMASKED_SYMBOL_COUNTER_VALID_INTERRUPT</name>
              <bitRange>[21:21]</bitRange>
              <description>Retention unmasked symbol counter interrupt</description>
            </field>
            <field>
              <name>RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_DONE_INTERRUPT</name>
              <bitRange>[22:22]</bitRange>
              <description>Unmasked Oscillator Benchmark Done Interrupt</description>
            </field>
            <field>
              <name>RETENTION_UNMASKED_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT</name>
              <bitRange>[23:23]</bitRange>
              <description>Unmasked Oscillator Benchmark sub measurement Done Interrupt</description>
            </field>
            <field>
              <name>RETENTION_UNMASKED_RELATIVE_EVENT_INTERRUPT</name>
              <bitRange>[24:24]</bitRange>
              <description>Retention unmasked Relative Event Interrupt</description>
            </field>
            <field>
              <name>RETENTION_UNMASKED_EXTERNAL_EVENT_INTERRUPT</name>
              <bitRange>[25:25]</bitRange>
              <description>Retention unmasked External Event Interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ES_0X00000074</name>
          <addressOffset>0x0074</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CALIBRATION_FACTOR_ADJUSTMENT</name>
              <bitRange>[31:0]</bitRange>
              <description>Calibration factor adjustment</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>INT_CTRL</name>
      <baseAddress>0x40000B00</baseAddress>
      <registers>
        <register>
          <name>INT_CTRL_GLOBAL_INTERRUPTS_ENABLE</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GLOBAL_INTERRUPTS_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>This bit enables the external interrupts</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_UNMASKED_INTERRUPTS[0]</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_I2CM_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>unmasked I2C master interrupt</description>
            </field>
            <field>
              <name>UNMASKED_KEYPAD_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>unmasked KeyPad Scan interrupt</description>
            </field>
            <field>
              <name>UNMASKED_STBC_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>unmasked standby controller interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>UNMASKED_IR_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>unmasked IR driver interrupt</description>
            </field>
            <field>
              <name>UNMASKED_RPA_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>unmasked RPA accelerator interrupt</description>
            </field>
            <field>
              <name>UNMASKED_QTA_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>unmasked qta interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>UNMASKED_WATCHDOG_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>unmasked watchdog interrupt</description>
            </field>
            <field>
              <name>UNMASKED_ES_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>unmasked ES interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_UNMASKED_INTERRUPTS[1]</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_UART_1_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>unmasked UART interrupt</description>
            </field>
            <field>
              <name>UNMASKED_UART_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>unmasked UART interrupt</description>
            </field>
            <field>
              <name>UNMASKED_PARFCS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>unmasked parfcs filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>UNMASKED_RCI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>unmasked RCI interrupt</description>
            </field>
            <field>
              <name>UNMASKED_ADCIF_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>unmasked ADC interface interrupt</description>
            </field>
            <field>
              <name>UNMASKED_ASP_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>unmasked ASP interface interrupt</description>
            </field>
            <field>
              <name>UNMASKED_SSP_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>unmasked security processor interrupt</description>
            </field>
            <field>
              <name>UNMASKED_I2SM_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>unmasked I2S master interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_UNMASKED_INTERRUPTS[2]</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PHY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>unmasked Phy interrupt</description>
            </field>
            <field>
              <name>UNMASKED_SECPROC_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>unmasked Security Processor interrupt</description>
            </field>
            <field>
              <name>UNMASKED_SPIM_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>unmasked SPI Master interrupt</description>
            </field>
            <field>
              <name>UNMASKED_GPMICRO_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>unmasked gpmicro interrupt</description>
            </field>
            <field>
              <name>UNMASKED_BBPLL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>unmasked BBPLL interrupt</description>
            </field>
            <field>
              <name>UNMASKED_SPISL_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>unmasked SPI Slave interrupt</description>
            </field>
            <field>
              <name>UNMASKED_DMAS_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>unmasked DMA SCB engine interrupt</description>
            </field>
            <field>
              <name>UNMASKED_GPIO_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>unmasked gpio external interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_UNMASKED_INTERRUPTS[3]</name>
          <addressOffset>0x0007</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>unmasked trc interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>UNMASKED_PARBLE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>unmasked parble filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>UNMASKED_TIMERS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>unmasked timer interrupt</description>
            </field>
            <field>
              <name>UNMASKED_MRI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>unmasked mri interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>UNMASKED_I2CSL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>unmasked I2C Slave interrupt</description>
            </field>
            <field>
              <name>UNMASKED_PWMS_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>unmasked PWM interrupt</description>
            </field>
            <field>
              <name>UNMASKED_IPCX2GPM_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>unmasked inter process communication interrupt (... 2 gpm)</description>
            </field>
            <field>
              <name>UNMASKED_IPCEXT2X_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>unmasked inter process communication interrupt (ext 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_UNMASKED_INTERRUPTS[4]</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_IPCX2INT_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>unmasked inter process communication interrupt (... 2 int)</description>
            </field>
            <field>
              <name>UNMASKED_IPCX2EXT_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>unmasked inter process communication interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>UNMASKED_IPCGPM2X_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>unmasked inter process communication interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>UNMASKED_IPCINT2X_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>unmasked inter process communication interrupt (int 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_EXT_INTERRUPTS[0]</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_EXT_I2CM_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked external I2C master interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_KEYPAD_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked external KeyPad Scan interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_STBC_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked external standby controller interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASKED_EXT_IR_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked external IR driver interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_RPA_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked external RPA accelerator interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_QTA_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked external qta interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_EXT_WATCHDOG_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked external watchdog interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_ES_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked external ES interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_EXT_INTERRUPTS[1]</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_EXT_UART_1_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked external UART interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_UART_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked external UART interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_PARFCS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked external parfcs filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_EXT_RCI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked external RCI interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_ADCIF_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked external ADC interface interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_ASP_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked external ASP interface interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_SSP_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked external security processor interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_I2SM_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked external I2S master interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_EXT_INTERRUPTS[2]</name>
          <addressOffset>0x000E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_EXT_PHY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked external Phy interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_SECPROC_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked external Security Processor interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_SPIM_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked external SPI Master interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_GPMICRO_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked external gpmicro interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_BBPLL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked external BBPLL interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_SPISL_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked external SPI Slave interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_DMAS_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked external DMA SCB engine interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_GPIO_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked external gpio external interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_EXT_INTERRUPTS[3]</name>
          <addressOffset>0x000F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_EXT_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked external trc interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_EXT_PARBLE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked external parble filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_EXT_TIMERS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked external timer interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_MRI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked external mri interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASKED_EXT_I2CSL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked external I2C Slave interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_PWMS_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked external PWM interrupt</description>
            </field>
            <field>
              <name>MASKED_EXT_IPCX2EXT_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked external inter process communication interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASKED_EXT_IPCGPM2X_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked external inter process communication interrupt (gpm 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_EXT_INTERRUPTS[4]</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_EXT_IPCINT2X_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked external inter process communication interrupt (int 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_EXT_INTERRUPTS[0]</name>
          <addressOffset>0x0014</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_EXT_I2CM_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask external I2C master interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_KEYPAD_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask external KeyPad Scan interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_STBC_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask external standby controller interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASK_EXT_IR_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask external IR driver interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_RPA_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask external RPA accelerator interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_QTA_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask external qta interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_EXT_WATCHDOG_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask external watchdog interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_ES_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask external ES interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_EXT_INTERRUPTS[1]</name>
          <addressOffset>0x0015</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_EXT_UART_1_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask external UART interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_UART_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask external UART interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_PARFCS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask external parfcs filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_EXT_RCI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask external RCI interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_ADCIF_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask external ADC interface interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_ASP_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask external ASP interface interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_SSP_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask external security processor interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_I2SM_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask external I2S master interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_EXT_INTERRUPTS[2]</name>
          <addressOffset>0x0016</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_EXT_PHY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask external Phy interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_SECPROC_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask external Security Processor interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_SPIM_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask external SPI Master interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_GPMICRO_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask external gpmicro interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_BBPLL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask external BBPLL interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_SPISL_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask external SPI Slave interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_DMAS_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask external DMA SCB engine interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_GPIO_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask external gpio external interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_EXT_INTERRUPTS[3]</name>
          <addressOffset>0x0017</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_EXT_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask external trc interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_EXT_PARBLE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask external parble filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_EXT_TIMERS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask external timer interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_MRI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask external mri interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASK_EXT_I2CSL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask external I2C Slave interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_PWMS_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask external PWM interrupt</description>
            </field>
            <field>
              <name>MASK_EXT_IPCX2EXT_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask external inter process communication interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASK_EXT_IPCGPM2X_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask external inter process communication interrupt (gpm 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_EXT_INTERRUPTS[4]</name>
          <addressOffset>0x0018</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_EXT_IPCINT2X_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask external inter process communication interrupt (int 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_INT_INTERRUPTS[0]</name>
          <addressOffset>0x001C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_INT_I2CM_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked internal I2C master interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_KEYPAD_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked internal KeyPad Scan interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_STBC_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked internal standby controller interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASKED_INT_IR_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked internal IR driver interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_RPA_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked internal RPA accelerator interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_QTA_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked internal qta interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_INT_WATCHDOG_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked internal watchdog interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_ES_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked internal ES interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_INT_INTERRUPTS[1]</name>
          <addressOffset>0x001D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_INT_UART_1_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked internal UART interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_UART_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked internal UART interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_PARFCS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked internal parfcs filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_INT_RCI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked internal RCI interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_ADCIF_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked internal ADC interface interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_ASP_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked internal ASP interface interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_SSP_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked internal security processor interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_I2SM_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked internal I2S master interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_INT_INTERRUPTS[2]</name>
          <addressOffset>0x001E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_INT_PHY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked internal Phy interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_SECPROC_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked internal Security Processor interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_SPIM_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked internal SPI Master interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_GPMICRO_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked internal gpmicro interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_BBPLL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked internal BBPLL interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_SPISL_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked internal SPI Slave interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_DMAS_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked internal DMA SCB engine interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_GPIO_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked internal gpio external interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_INT_INTERRUPTS[3]</name>
          <addressOffset>0x001F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_INT_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked internal trc interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_INT_PARBLE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked internal parble filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASKED_INT_TIMERS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked internal timer interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_MRI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked internal mri interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASKED_INT_I2CSL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked internal I2C Slave interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_PWMS_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked internal PWM interrupt</description>
            </field>
            <field>
              <name>MASKED_INT_IPCEXT2X_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked internal inter process communication interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASKED_INT_IPCX2INT_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked internal inter process communication interrupt (... 2 int)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_INT_INTERRUPTS[4]</name>
          <addressOffset>0x0020</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_INT_IPCGPM2X_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked internal inter process communication interrupt (gpm 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_INT_INTERRUPTS[0]</name>
          <addressOffset>0x0024</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_INT_I2CM_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask internal I2C master interrupt</description>
            </field>
            <field>
              <name>MASK_INT_KEYPAD_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask internal KeyPad Scan interrupt</description>
            </field>
            <field>
              <name>MASK_INT_STBC_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask internal standby controller interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASK_INT_IR_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask internal IR driver interrupt</description>
            </field>
            <field>
              <name>MASK_INT_RPA_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask internal RPA accelerator interrupt</description>
            </field>
            <field>
              <name>MASK_INT_QTA_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask internal qta interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_INT_WATCHDOG_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask internal watchdog interrupt</description>
            </field>
            <field>
              <name>MASK_INT_ES_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask internal ES interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_INT_INTERRUPTS[1]</name>
          <addressOffset>0x0025</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_INT_UART_1_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask internal UART interrupt</description>
            </field>
            <field>
              <name>MASK_INT_UART_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask internal UART interrupt</description>
            </field>
            <field>
              <name>MASK_INT_PARFCS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask internal parfcs filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_INT_RCI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask internal RCI interrupt</description>
            </field>
            <field>
              <name>MASK_INT_ADCIF_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask internal ADC interface interrupt</description>
            </field>
            <field>
              <name>MASK_INT_ASP_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask internal ASP interface interrupt</description>
            </field>
            <field>
              <name>MASK_INT_SSP_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask internal security processor interrupt</description>
            </field>
            <field>
              <name>MASK_INT_I2SM_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask internal I2S master interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_INT_INTERRUPTS[2]</name>
          <addressOffset>0x0026</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_INT_PHY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask internal Phy interrupt</description>
            </field>
            <field>
              <name>MASK_INT_SECPROC_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask internal Security Processor interrupt</description>
            </field>
            <field>
              <name>MASK_INT_SPIM_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask internal SPI Master interrupt</description>
            </field>
            <field>
              <name>MASK_INT_GPMICRO_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask internal gpmicro interrupt</description>
            </field>
            <field>
              <name>MASK_INT_BBPLL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask internal BBPLL interrupt</description>
            </field>
            <field>
              <name>MASK_INT_SPISL_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask internal SPI Slave interrupt</description>
            </field>
            <field>
              <name>MASK_INT_DMAS_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask internal DMA SCB engine interrupt</description>
            </field>
            <field>
              <name>MASK_INT_GPIO_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask internal gpio external interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_INT_INTERRUPTS[3]</name>
          <addressOffset>0x0027</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_INT_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask internal trc interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_INT_PARBLE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask internal parble filter interrupt (same for internal and external)</description>
            </field>
            <field>
              <name>MASK_INT_TIMERS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask internal timer interrupt</description>
            </field>
            <field>
              <name>MASK_INT_MRI_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask internal mri interrupt (internal and external are the same)</description>
            </field>
            <field>
              <name>MASK_INT_I2CSL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask internal I2C Slave interrupt</description>
            </field>
            <field>
              <name>MASK_INT_PWMS_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask internal PWM interrupt</description>
            </field>
            <field>
              <name>MASK_INT_IPCEXT2X_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask internal inter process communication interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASK_INT_IPCX2INT_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>mask internal inter process communication interrupt (... 2 int)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_INT_INTERRUPTS[4]</name>
          <addressOffset>0x0028</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_INT_IPCGPM2X_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask internal inter process communication interrupt (gpm 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_UNMASKED_GPM_INTERRUPTS</name>
          <addressOffset>0x0029</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_GPM_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>unmasked trc interrupt for gpmicro</description>
            </field>
            <field>
              <name>UNMASKED_GPM_PHY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>unmasked Phy interrupt for gpmicro</description>
            </field>
            <field>
              <name>UNMASKED_GPM_ES_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>unmasked ES interrupt for gpmicro</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_GPM_INTERRUPTS</name>
          <addressOffset>0x002A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_GPM_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked trc interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASKED_GPM_PARBLE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked parble filter interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASKED_GPM_RPA_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked RPA accelerator interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASKED_GPM_PARFCS_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked parfcs filter interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASKED_GPM_PHY_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked Phy interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked ES interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASKED_GPM_IPCX2GPM_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked inter process communication interrupt (... 2 gpm) for gpmicro</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_GPM_INTERRUPTS</name>
          <addressOffset>0x002B</addressOffset>
          <size>8</size>
          <resetValue>0x0000001A</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_GPM_TRC_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>mask trc interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASK_GPM_PARBLE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>mask parble filter interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASK_GPM_RPA_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>mask RPA accelerator interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASK_GPM_PARFCS_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>mask parfcs filter interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASK_GPM_PHY_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>mask Phy interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASK_GPM_ES_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>mask ES interrupt for gpmicro</description>
            </field>
            <field>
              <name>MASK_GPM_IPCX2GPM_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>mask inter process communication interrupt (... 2 gpm) for gpmicro</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_GPM_ES_INTERRUPTS</name>
          <addressOffset>0x002C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_GPM_ES_EVENT_INTERRUPTS</name>
              <bitRange>[15:0]</bitRange>
              <description>masks the Event Interrupts</description>
            </field>
            <field>
              <name>MASK_GPM_ES_COMP_EVENT_INTERRUPTS</name>
              <bitRange>[19:16]</bitRange>
              <description>masks the Comparator Event interrupts</description>
            </field>
            <field>
              <name>MASK_GPM_ES_WAKEUP_ON_RF_EVENT_INTERRUPT</name>
              <bitRange>[20:20]</bitRange>
              <description>masks the Wakeup_on_rf Event interrupt</description>
            </field>
            <field>
              <name>MASK_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT</name>
              <bitRange>[21:21]</bitRange>
              <description>masks the es symbol counter interrupt</description>
            </field>
            <field>
              <name>MASK_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT</name>
              <bitRange>[22:22]</bitRange>
              <description>masks the es oscillator benchmark interrupt</description>
            </field>
            <field>
              <name>MASK_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT</name>
              <bitRange>[23:23]</bitRange>
              <description>masks the es oscillator benchmark sub measurement done interrupt</description>
            </field>
            <field>
              <name>MASK_GPM_ES_RELATIVE_EVENT_INTERRUPT</name>
              <bitRange>[24:24]</bitRange>
              <description>masks the es Relative Event Interrupt</description>
            </field>
            <field>
              <name>MASK_GPM_ES_EXTERNAL_EVENT_INTERRUPT</name>
              <bitRange>[25:25]</bitRange>
              <description>masks the External Event Interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_GPM_PHY_INTERRUPTS</name>
          <addressOffset>0x0030</addressOffset>
          <size>8</size>
          <resetValue>0x00000010</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the interrupt for the fll rx out of range event</description>
            </field>
            <field>
              <name>MASK_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the interrupt for the fll tx out of range event</description>
            </field>
            <field>
              <name>MASK_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the interrupt for the fll tx_out of lock event</description>
            </field>
            <field>
              <name>MASK_GPM_PHY_FLL_FE_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASK_GPM_PHY_FLL_CAL_START_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASK_GPM_PHY_RX_MODE_CHANGE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the interrupt for rx_mode changes</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_GPM_TRC_INTERRUPTS[0]</name>
          <addressOffset>0x0034</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_GPM_TRC_PBM_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_TX_STARTED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_TX_ACK_STARTED_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_TX_DONE_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_GPM_TRC_INTERRUPTS[1]</name>
          <addressOffset>0x0035</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_GPM_TRC_CAL_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_CAL_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_CAL_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_CAL_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_CAL_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_CAL_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_CAL_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_GPM_TRC_INTERRUPTS[2]</name>
          <addressOffset>0x0036</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_ES_INTERRUPTS</name>
          <addressOffset>0x0038</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_ES_EVENT_INTERRUPTS</name>
              <bitRange>[15:0]</bitRange>
              <description>masks the Event Interrupts</description>
            </field>
            <field>
              <name>MASK_ES_COMP_EVENT_INTERRUPTS</name>
              <bitRange>[19:16]</bitRange>
              <description>masks the Comparator Event interrupts</description>
            </field>
            <field>
              <name>MASK_ES_WAKEUP_ON_RF_EVENT_INTERRUPT</name>
              <bitRange>[20:20]</bitRange>
              <description>masks the Wakeup_on_rf Event interrupt</description>
            </field>
            <field>
              <name>MASK_ES_SYMBOL_COUNTER_VALID_INTERRUPT</name>
              <bitRange>[21:21]</bitRange>
              <description>masks the es symbol counter interrupt</description>
            </field>
            <field>
              <name>MASK_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT</name>
              <bitRange>[22:22]</bitRange>
              <description>masks the es oscillator benchmark interrupt</description>
            </field>
            <field>
              <name>MASK_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT</name>
              <bitRange>[23:23]</bitRange>
              <description>masks the es oscillator benchmark sub meas done interrupt</description>
            </field>
            <field>
              <name>MASK_ES_RELATIVE_EVENT_INTERRUPT</name>
              <bitRange>[24:24]</bitRange>
              <description>masks the es Relative Event Interrupt</description>
            </field>
            <field>
              <name>MASK_ES_EXTERNAL_EVENT_INTERRUPT</name>
              <bitRange>[25:25]</bitRange>
              <description>masks the External Event Interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_DMAS_INTERRUPTS[0]</name>
          <addressOffset>0x003C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_DMAS_INTERRUPTS[1]</name>
          <addressOffset>0x003D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_6_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_DMAS_BUFFER_COMPLETE_7_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_DMAS_INTERRUPTS[2]</name>
          <addressOffset>0x003E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_DMAS_CPY_ERR_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_QTA_INTERRUPTS</name>
          <addressOffset>0x003F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_QTA_SCH0_EMPTY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_QTA_SCH1_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_QTA_SCH2_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_QTA_SCH3_EMPTY_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_QTA_QUEUE_FULL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_TRC_INTERRUPTS[0]</name>
          <addressOffset>0x0040</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_TRC_PBM_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_TX_STARTED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_TX_ACK_STARTED_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_TX_DONE_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_TRC_INTERRUPTS[1]</name>
          <addressOffset>0x0041</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_TRC_CAL_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_CAL_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_CAL_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_CAL_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_CAL_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_CAL_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_CAL_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_TRC_INTERRUPTS[2]</name>
          <addressOffset>0x0042</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_TRC_RX_WINDOW_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_RX_WINDOW_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_RX_WINDOW_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_RX_WINDOW_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_RX_WINDOW_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_RX_WINDOW_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TRC_RX_WINDOW_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_PARBLE_INTERRUPTS</name>
          <addressOffset>0x0043</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_PARBLE_LEVEL_TRIGGER_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>triggering an interrupt when n bytes were received</description>
            </field>
            <field>
              <name>MASK_PARBLE_PACKET_DONE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_STBC_INTERRUPTS</name>
          <addressOffset>0x0044</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_STBC_PORD_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the standby controller event power on reset detected interrupt</description>
            </field>
            <field>
              <name>MASK_STBC_ACTIVE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the standby controller Active state interrupt</description>
            </field>
            <field>
              <name>MASK_STBC_VLT_STATUS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the standby controller vlt_status interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_I2CM_INTERRUPTS</name>
          <addressOffset>0x0045</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_I2CM_DONE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the I2C master done interrupt</description>
            </field>
            <field>
              <name>MASK_I2CM_ARB_LOST_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the I2C master arbitration lost interrupt</description>
            </field>
            <field>
              <name>MASK_I2CM_CLK_SYNC_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the I2C master clock synchronization slave wait interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_RCI_INTERRUPTS</name>
          <addressOffset>0x0046</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_RCI_DATA_IND_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_DATA_CNF_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_DATA_CNF_INTERRUPTS</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_DATA_CNF_1_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_DATA_CNF_2_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_DATA_CNF_3_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_BLE_DATA_IND_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_BLE_ADV_IND_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_BLE_CONN_REQ_IND_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_BLE_CONN_RSP_IND_INTERRUPT</name>
              <bitRange>[8:8]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_RCI_BLE_DATA_CNF_INTERRUPT</name>
              <bitRange>[9:9]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_PHY_INTERRUPTS</name>
          <addressOffset>0x0048</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the interrupt for the fll rx out of range event</description>
            </field>
            <field>
              <name>MASK_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the interrupt for the fll tx out of range event</description>
            </field>
            <field>
              <name>MASK_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the interrupt for the fll tx_out of lock event</description>
            </field>
            <field>
              <name>MASK_PHY_FLL_FE_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASK_PHY_FLL_CAL_START_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASK_PHY_RX_MODE_CHANGE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the interrupt for rx_mode changes</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_GPIO_INTERRUPTS</name>
          <addressOffset>0x0049</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_GPIO_EXTI0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the gpio interrupts for exti 0 of the selected port</description>
            </field>
            <field>
              <name>MASK_GPIO_EXTI1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the gpio interrupts for exti 1 of the selected port</description>
            </field>
            <field>
              <name>MASK_GPIO_EXTI2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the gpio interrupts for exti 2 of the selected port</description>
            </field>
            <field>
              <name>MASK_GPIO_EXTI3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the gpio interrupts for exti 3 of the selected port</description>
            </field>
            <field>
              <name>MASK_GPIO_EXTI4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the gpio interrupts for exti 4 of the selected port</description>
            </field>
            <field>
              <name>MASK_GPIO_EXTI5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the gpio interrupts for exti 5 of the selected port</description>
            </field>
            <field>
              <name>MASK_GPIO_EXTI6_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masks the gpio interrupts for exti 6 of the selected port</description>
            </field>
            <field>
              <name>MASK_GPIO_EXTI7_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masks the gpio interrupts for exti 7 of the selected port</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_SPIM_INTERRUPTS</name>
          <addressOffset>0x004A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_SPIM_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the SPI master transfer not busy interrupt</description>
            </field>
            <field>
              <name>MASK_SPIM_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the SPI master TX buffer empty interrupt</description>
            </field>
            <field>
              <name>MASK_SPIM_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the SPI master RX buffer not empty interrupt</description>
            </field>
            <field>
              <name>MASK_SPIM_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the SPI master RX buffer overrun interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_SPISL_INTERRUPTS</name>
          <addressOffset>0x004B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_SPISL_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the SPI slave TX buffer empty interrupt</description>
            </field>
            <field>
              <name>MASK_SPISL_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the SPI slave RX buffer not empty interrupt</description>
            </field>
            <field>
              <name>MASK_SPISL_TX_UNDERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the SPI slave TX buffer underrun interrupt</description>
            </field>
            <field>
              <name>MASK_SPISL_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the SPI slave RX buffer overrun interrupt</description>
            </field>
            <field>
              <name>MASK_SPISL_TX_EMPTY_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the SPI slave TX empty interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCGPM2X_INTERRUPTS[0]</name>
          <addressOffset>0x004C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCGPM2X_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_CMD_PROCESSED_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Indicates that an internal cmd is processed</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the gpmicro error interrupt</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_UNEXPECTED_COND_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masks the gpmicro unexpected condition interrupt</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_STAT_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masks the gpmicro status interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCGPM2X_INTERRUPTS[1]</name>
          <addressOffset>0x004D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCGPM2X_ADV_TX_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates a frame is sent during an advertising event</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_SCAN_REQ_RX_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates a scan request has been received</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_SCAN_RSP_TX_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Indicates a scan response is sent</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_SCAN_REQ_TX_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Indicates that a SCAN_REQ frame is sent</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_CONN_REQ_TX_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Indicates that a CONN_REQ frame is sent</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_SUBEV_DONE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Indicates that a subevent has been processed</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_EVENT_PROCESSED_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>Indicates that a ble event has been processed</description>
            </field>
            <field>
              <name>MASK_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>Indicates that a connection ble event has reached its last_sch_event_cnt (if enabled)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCGPM2X_INTERRUPTS[2]</name>
          <addressOffset>0x004E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCGPM2X_EVENT_SKIPPED_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates that a ble event has been skipped</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCX2GPM_INTERRUPTS</name>
          <addressOffset>0x004F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCX2GPM_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_IPCX2GPM_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_IPCX2GPM_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_IPCX2GPM_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_IPCX2GPM_CMD_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Indicates that a cmd is available to be processed</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCINT2X_INTERRUPTS</name>
          <addressOffset>0x0050</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCINT2X_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the inter processor communication source interrupt (int 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCINT2X_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the inter processor communication source interrupt (int 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCINT2X_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the inter processor communication source interrupt (int 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCINT2X_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the inter processor communication source interrupt (int 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCX2INT_INTERRUPTS</name>
          <addressOffset>0x0051</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCX2INT_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 int)</description>
            </field>
            <field>
              <name>MASK_IPCX2INT_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 int)</description>
            </field>
            <field>
              <name>MASK_IPCX2INT_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 int)</description>
            </field>
            <field>
              <name>MASK_IPCX2INT_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 int)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCEXT2X_INTERRUPTS</name>
          <addressOffset>0x0052</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCEXT2X_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the inter processor communication source interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCEXT2X_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the inter processor communication source interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCEXT2X_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the inter processor communication source interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASK_IPCEXT2X_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the inter processor communication source interrupt (ext 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IPCX2EXT_INTERRUPTS</name>
          <addressOffset>0x0053</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IPCX2EXT_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASK_IPCX2EXT_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASK_IPCX2EXT_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASK_IPCX2EXT_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the inter processor communication source interrupt (... 2 ext)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_I2CSL_INTERRUPTS</name>
          <addressOffset>0x0054</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_I2CSL_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the TX buffer not full interrupt.</description>
            </field>
            <field>
              <name>MASK_I2CSL_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the RX buffer not empty interrupt</description>
            </field>
            <field>
              <name>MASK_I2CSL_TX_STRETCH_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the TX stretch interrupt.</description>
            </field>
            <field>
              <name>MASK_I2CSL_START_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the I2C START event occurred interrupt</description>
            </field>
            <field>
              <name>MASK_I2CSL_STOP_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the I2C STOP event occurred interrupt</description>
            </field>
            <field>
              <name>MASK_I2CSL_SLAD_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the I2C SLAD event occurred interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_PWMS_INTERRUPTS[0]</name>
          <addressOffset>0x0058</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm0</description>
            </field>
            <field>
              <name>MASK_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm1</description>
            </field>
            <field>
              <name>MASK_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm2</description>
            </field>
            <field>
              <name>MASK_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm3</description>
            </field>
            <field>
              <name>MASK_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm4</description>
            </field>
            <field>
              <name>MASK_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm5</description>
            </field>
            <field>
              <name>MASK_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm6</description>
            </field>
            <field>
              <name>MASK_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masks the PWM threshold_match interrupt of pwm7</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_PWMS_INTERRUPTS[1]</name>
          <addressOffset>0x0059</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the PWM next threshold underrun interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the PWM next threshold not full interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP_OVERRUN_INTERRUPT</name>
              <bitRange>[5:2]</bitRange>
              <description>masks the PWM timestamp overrun interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the PWM timestamp0 overrun interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the PWM timestamp1 overrun interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the PWM timestamp2 overrun interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the PWM timestamp3 overrun interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT[0]</name>
              <bitRange>[7:6]</bitRange>
              <description>masks the PWM timestamp not empty interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masks the PWM timestamp0 not empty interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masks the PWM timestamp1 not empty interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_PWMS_INTERRUPTS[2]</name>
          <addressOffset>0x005A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT[1]</name>
              <bitRange>[1:0]</bitRange>
              <description>masks the PWM timestamp not empty interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the PWM timestamp2 not empty interrupt</description>
            </field>
            <field>
              <name>MASK_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the PWM timestamp3 not empty interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_ADCIF_INTERRUPTS</name>
          <addressOffset>0x005C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_ADCIF_BUFFER_A_UPDATED_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the buffer a updated interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_BUFFER_B_UPDATED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the buffer b updated interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_BUFFER_C_UPDATED_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the buffer c updated interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_FIFO_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the fifo not empty interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_FIFO_OVERRUN_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the fifo overrun interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_CYCLE_DONE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the cycle done interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_OVERVOLTAGE_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masks the fifo overvoltage interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masks the analog watchdog value above maximum interrupt</description>
            </field>
            <field>
              <name>MASK_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT</name>
              <bitRange>[8:8]</bitRange>
              <description>masks the analog watchdog value below minimum interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_UART_0_INTERRUPTS</name>
          <addressOffset>0x005E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_UART_0_TX_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the TX not busy interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_0_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the TX not full interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_0_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the RX not empty interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_0_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the RX overrun interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_0_RX_PARITY_ERROR_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the RX parity error interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_0_RX_FRAMING_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the RX framing error interrupt.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_UART_1_INTERRUPTS</name>
          <addressOffset>0x005F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_UART_1_TX_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the TX not busy interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_1_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the TX not full interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_1_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the RX not empty interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_1_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the RX overrun interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_1_RX_PARITY_ERROR_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the RX parity error interrupt.</description>
            </field>
            <field>
              <name>MASK_UART_1_RX_FRAMING_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the RX framing error interrupt.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_TIMERS_INTERRUPTS</name>
          <addressOffset>0x0060</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_TIMERS_TMR0_WRAP_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TIMERS_TMR1_WRAP_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TIMERS_TMR2_WRAP_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TIMERS_TMR3_WRAP_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_TIMERS_TMR4_WRAP_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_IR_INTERRUPTS</name>
          <addressOffset>0x0061</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_IR_SEQUENCE_START_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_IR_SEQUENCE_REPEAT_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_IR_SEQUENCE_DONE_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_IR_INDEX_MATCH_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_ASP_INTERRUPTS</name>
          <addressOffset>0x0062</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_ASP_DATASTREAM_0_VALID_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_ASP_DATASTREAM_1_VALID_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_I2SM_INTERRUPTS</name>
          <addressOffset>0x0063</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_I2SM_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_I2SM_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_BBPLL_INTERRUPTS</name>
          <addressOffset>0x0064</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_IN_LOCK_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASK_BBPLL_OUT_OF_LOCK_INTERRUPT</name>
              <bitRange>[8:8]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_SECPROC_INTERRUPTS</name>
          <addressOffset>0x0066</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_SECPROC_CRYPTO_MASTER_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the interrupt triggered by the CryptoMaster submodule, i.e. the symmetric cryptographic operations engine</description>
            </field>
            <field>
              <name>MASK_SECPROC_TRNG_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the interrupt triggered by the NDRNG submodule, i.e. the Non-Deterministic Random Number Generator</description>
            </field>
            <field>
              <name>MASK_SECPROC_PKE_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the interrupt triggered by the Public Key submodule, i.e. the asymmetric cryptographic operations engine</description>
            </field>
            <field>
              <name>MASK_SECPROC_ERR_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the interrupt triggered when the internal DMA runs into a memory bus error</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASK_SINGLE_INTERRUPTS</name>
          <addressOffset>0x0067</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MASK_PARFCS_LEVEL_TRIGGER_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masks the triggering an interrupt when n bytes were received</description>
            </field>
            <field>
              <name>MASK_MRI_ACCESS_DONE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masks the mri write interrupt</description>
            </field>
            <field>
              <name>MASK_GPMICRO_MEM_EXCEPTION_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masks the mem exception of gpmicro interrupt.</description>
            </field>
            <field>
              <name>MASK_WATCHDOG_TIMER_EXPIRED_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masks the watchdog timer expired interrupt</description>
            </field>
            <field>
              <name>MASK_SSP_DONE_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masks the ssp done interrupt</description>
            </field>
            <field>
              <name>MASK_RPA_DONE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masks the rpa done interrupt</description>
            </field>
            <field>
              <name>MASK_KEYPAD_SCAN_DONE_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masks the keypad scan done interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_GPM_ES_INTERRUPTS</name>
          <addressOffset>0x0068</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_GPM_ES_EVENT_INTERRUPTS</name>
              <bitRange>[15:0]</bitRange>
              <description>masked Event Interrupts</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_COMP_EVENT_INTERRUPTS</name>
              <bitRange>[19:16]</bitRange>
              <description>masked Comparator Event interrupts</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_WAKEUP_ON_RF_EVENT_INTERRUPT</name>
              <bitRange>[20:20]</bitRange>
              <description>masked Wakeup_on_rf Event interrupt</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_SYMBOL_COUNTER_VALID_INTERRUPT</name>
              <bitRange>[21:21]</bitRange>
              <description>masked es symbol counter interrupt</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT</name>
              <bitRange>[22:22]</bitRange>
              <description>masked es oscillator benchmark interrupt</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT</name>
              <bitRange>[23:23]</bitRange>
              <description>masked es oscillator benchmark sub measurement done interrupt</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_RELATIVE_EVENT_INTERRUPT</name>
              <bitRange>[24:24]</bitRange>
              <description>masked es Relative Event Interrupt</description>
            </field>
            <field>
              <name>MASKED_GPM_ES_EXTERNAL_EVENT_INTERRUPT</name>
              <bitRange>[25:25]</bitRange>
              <description>masked External Event Interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_GPM_PHY_INTERRUPTS</name>
          <addressOffset>0x006C</addressOffset>
          <size>8</size>
          <resetValue>0x00000010</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_GPM_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked interrupt for the fll rx out of range event</description>
            </field>
            <field>
              <name>MASKED_GPM_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked interrupt for the fll tx out of range event</description>
            </field>
            <field>
              <name>MASKED_GPM_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked interrupt for the fll tx_out of lock event</description>
            </field>
            <field>
              <name>MASKED_GPM_PHY_FLL_FE_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASKED_GPM_PHY_FLL_CAL_START_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASKED_GPM_PHY_RX_MODE_CHANGE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked interrupt for rx_mode changes</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_GPM_TRC_INTERRUPTS[0]</name>
          <addressOffset>0x0070</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_GPM_TRC_PBM_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_TX_STARTED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_TX_ACK_STARTED_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_TX_DONE_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_GPM_TRC_INTERRUPTS[1]</name>
          <addressOffset>0x0071</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_GPM_TRC_CAL_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_CAL_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_CAL_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_CAL_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_CAL_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_CAL_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_CAL_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_GPM_TRC_INTERRUPTS[2]</name>
          <addressOffset>0x0072</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_GPM_TRC_RX_WINDOW_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_RX_WINDOW_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_RX_WINDOW_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_RX_WINDOW_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_RX_WINDOW_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_RX_WINDOW_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_GPM_TRC_RX_WINDOW_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_ES_INTERRUPTS</name>
          <addressOffset>0x0074</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_ES_EVENT_INTERRUPTS</name>
              <bitRange>[15:0]</bitRange>
              <description>masked Event Interrupts</description>
            </field>
            <field>
              <name>MASKED_ES_COMP_EVENT_INTERRUPTS</name>
              <bitRange>[19:16]</bitRange>
              <description>masked Comparator Event interrupts</description>
            </field>
            <field>
              <name>MASKED_ES_WAKEUP_ON_RF_EVENT_INTERRUPT</name>
              <bitRange>[20:20]</bitRange>
              <description>masked Wakeup_on_rf Event interrupt</description>
            </field>
            <field>
              <name>MASKED_ES_SYMBOL_COUNTER_VALID_INTERRUPT</name>
              <bitRange>[21:21]</bitRange>
              <description>masked es symbol counter interrupt</description>
            </field>
            <field>
              <name>MASKED_ES_OSCILLATOR_BENCHMARK_DONE_INTERRUPT</name>
              <bitRange>[22:22]</bitRange>
              <description>masked es oscillator benchmark interrupt</description>
            </field>
            <field>
              <name>MASKED_ES_OSCILLATOR_BENCHMARK_SUB_MEAS_DONE_INTERRUPT</name>
              <bitRange>[23:23]</bitRange>
              <description>masked es oscillator benchmark sub meas done interrupt</description>
            </field>
            <field>
              <name>MASKED_ES_RELATIVE_EVENT_INTERRUPT</name>
              <bitRange>[24:24]</bitRange>
              <description>masked es Relative Event Interrupt</description>
            </field>
            <field>
              <name>MASKED_ES_EXTERNAL_EVENT_INTERRUPT</name>
              <bitRange>[25:25]</bitRange>
              <description>masked External Event Interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_DMAS_INTERRUPTS[0]</name>
          <addressOffset>0x0078</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_6_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_ALMOST_COMPLETE_7_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_DMAS_INTERRUPTS[1]</name>
          <addressOffset>0x0079</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_6_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_DMAS_BUFFER_COMPLETE_7_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_DMAS_INTERRUPTS[2]</name>
          <addressOffset>0x007A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_DMAS_CPY_ERR_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_QTA_INTERRUPTS</name>
          <addressOffset>0x007B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_QTA_SCH0_EMPTY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_QTA_SCH1_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_QTA_SCH2_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_QTA_SCH3_EMPTY_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_QTA_QUEUE_FULL_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_TRC_INTERRUPTS[0]</name>
          <addressOffset>0x007C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_TRC_PBM_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_TX_STARTED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_TX_ACK_STARTED_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_PHY_TRANSITION_NOT_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_TX_DONE_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_MSG_REQ_WHILE_BUSY_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_TRC_INTERRUPTS[1]</name>
          <addressOffset>0x007D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_TRC_CAL_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_CAL_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_CAL_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_CAL_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_CAL_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_CAL_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_CAL_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_TRC_INTERRUPTS[2]</name>
          <addressOffset>0x007E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_TRC_RX_WINDOW_DONE_INTERRUPTS</name>
              <bitRange>[5:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_RX_WINDOW_DONE_CH0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_RX_WINDOW_DONE_CH1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_RX_WINDOW_DONE_CH2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_RX_WINDOW_DONE_CH3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_RX_WINDOW_DONE_CH4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TRC_RX_WINDOW_DONE_CH5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_PARBLE_INTERRUPTS</name>
          <addressOffset>0x007F</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_PARBLE_LEVEL_TRIGGER_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>triggering an interrupt when n bytes were received</description>
            </field>
            <field>
              <name>MASKED_PARBLE_PACKET_DONE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_STBC_INTERRUPTS</name>
          <addressOffset>0x0080</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_STBC_PORD_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked standby controller event power on reset detected interrupt</description>
            </field>
            <field>
              <name>MASKED_STBC_ACTIVE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked standby controller Active state interrupt</description>
            </field>
            <field>
              <name>MASKED_STBC_VLT_STATUS_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked standby controller vlt_status interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_I2CM_INTERRUPTS</name>
          <addressOffset>0x0081</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_I2CM_DONE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked I2C master done interrupt</description>
            </field>
            <field>
              <name>MASKED_I2CM_ARB_LOST_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked I2C master arbitration lost interrupt</description>
            </field>
            <field>
              <name>MASKED_I2CM_CLK_SYNC_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked I2C master clock synchronization slave wait interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_RCI_INTERRUPTS</name>
          <addressOffset>0x0082</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_RCI_DATA_IND_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_DATA_CNF_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_DATA_CNF_INTERRUPTS</name>
              <bitRange>[4:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_DATA_CNF_1_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_DATA_CNF_2_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_DATA_CNF_3_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_BLE_DATA_IND_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_BLE_ADV_IND_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_BLE_CONN_REQ_IND_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_BLE_CONN_RSP_IND_INTERRUPT</name>
              <bitRange>[8:8]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_RCI_BLE_DATA_CNF_INTERRUPT</name>
              <bitRange>[9:9]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_PHY_INTERRUPTS</name>
          <addressOffset>0x0084</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_PHY_FLL_RX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked interrupt for the fll rx out of range event</description>
            </field>
            <field>
              <name>MASKED_PHY_FLL_TX_OUT_OF_RANGE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked interrupt for the fll tx out of range event</description>
            </field>
            <field>
              <name>MASKED_PHY_FLL_TX_OUT_OF_LOCK_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked interrupt for the fll tx_out of lock event</description>
            </field>
            <field>
              <name>MASKED_PHY_FLL_FE_DONE_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASKED_PHY_FLL_CAL_START_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked interrupt for the fll fp out of range event</description>
            </field>
            <field>
              <name>MASKED_PHY_RX_MODE_CHANGE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked interrupt for rx_mode changes</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_GPIO_INTERRUPTS</name>
          <addressOffset>0x0085</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_GPIO_EXTI0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked gpio interrupts for exti 0 of the selected port</description>
            </field>
            <field>
              <name>MASKED_GPIO_EXTI1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked gpio interrupts for exti 1 of the selected port</description>
            </field>
            <field>
              <name>MASKED_GPIO_EXTI2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked gpio interrupts for exti 2 of the selected port</description>
            </field>
            <field>
              <name>MASKED_GPIO_EXTI3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked gpio interrupts for exti 3 of the selected port</description>
            </field>
            <field>
              <name>MASKED_GPIO_EXTI4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked gpio interrupts for exti 4 of the selected port</description>
            </field>
            <field>
              <name>MASKED_GPIO_EXTI5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked gpio interrupts for exti 5 of the selected port</description>
            </field>
            <field>
              <name>MASKED_GPIO_EXTI6_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked gpio interrupts for exti 6 of the selected port</description>
            </field>
            <field>
              <name>MASKED_GPIO_EXTI7_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked gpio interrupts for exti 7 of the selected port</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_SPIM_INTERRUPTS</name>
          <addressOffset>0x0086</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_SPIM_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked SPI master transfer not busy interrupt</description>
            </field>
            <field>
              <name>MASKED_SPIM_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked SPI master TX buffer empty interrupt</description>
            </field>
            <field>
              <name>MASKED_SPIM_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked SPI master RX buffer not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_SPIM_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked SPI master RX buffer overrun interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_SPISL_INTERRUPTS</name>
          <addressOffset>0x0087</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_SPISL_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked SPI slave TX buffer empty interrupt</description>
            </field>
            <field>
              <name>MASKED_SPISL_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked SPI slave RX buffer not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_SPISL_TX_UNDERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked SPI slave TX buffer underrun interrupt</description>
            </field>
            <field>
              <name>MASKED_SPISL_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked SPI slave RX buffer overrun interrupt</description>
            </field>
            <field>
              <name>MASKED_SPISL_TX_EMPTY_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked SPI slave TX empty interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCGPM2X_INTERRUPTS[0]</name>
          <addressOffset>0x0088</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCGPM2X_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked inter processor communication source interrupt (gpm 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_CMD_PROCESSED_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Indicates that an internal cmd is processed</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked gpmicro error interrupt</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_UNEXPECTED_COND_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked gpmicro unexpected condition interrupt</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_STAT_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked gpmicro status interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCGPM2X_INTERRUPTS[1]</name>
          <addressOffset>0x0089</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCGPM2X_ADV_TX_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates a frame is sent during an advertising event</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_SCAN_REQ_RX_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates a scan request has been received</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_SCAN_RSP_TX_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Indicates a scan response is sent</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_SCAN_REQ_TX_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Indicates that a SCAN_REQ frame is sent</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_CONN_REQ_TX_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Indicates that a CONN_REQ frame is sent</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_SUBEV_DONE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Indicates that a subevent has been processed</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_EVENT_PROCESSED_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>Indicates that a ble event has been processed</description>
            </field>
            <field>
              <name>MASKED_IPCGPM2X_LAST_CONN_EVENT_CNT_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>Indicates that a connection ble event has reached its last_sch_event_cnt (if enabled)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCGPM2X_INTERRUPTS[2]</name>
          <addressOffset>0x008A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCGPM2X_EVENT_SKIPPED_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates that a ble event has been skipped</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCX2GPM_INTERRUPTS</name>
          <addressOffset>0x008B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCX2GPM_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_IPCX2GPM_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_IPCX2GPM_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_IPCX2GPM_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_IPCX2GPM_CMD_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Indicates that a cmd is available to be processed</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCINT2X_INTERRUPTS</name>
          <addressOffset>0x008C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCINT2X_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked inter processor communication source interrupt (int 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCINT2X_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked inter processor communication source interrupt (int 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCINT2X_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked inter processor communication source interrupt (int 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCINT2X_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked inter processor communication source interrupt (int 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCX2INT_INTERRUPTS</name>
          <addressOffset>0x008D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCX2INT_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 int)</description>
            </field>
            <field>
              <name>MASKED_IPCX2INT_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 int)</description>
            </field>
            <field>
              <name>MASKED_IPCX2INT_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 int)</description>
            </field>
            <field>
              <name>MASKED_IPCX2INT_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 int)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCEXT2X_INTERRUPTS</name>
          <addressOffset>0x008E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCEXT2X_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked inter processor communication source interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCEXT2X_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked inter processor communication source interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCEXT2X_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked inter processor communication source interrupt (ext 2 ...)</description>
            </field>
            <field>
              <name>MASKED_IPCEXT2X_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked inter processor communication source interrupt (ext 2 ...)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IPCX2EXT_INTERRUPTS</name>
          <addressOffset>0x008F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IPCX2EXT_FLAG_A_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASKED_IPCX2EXT_FLAG_B_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASKED_IPCX2EXT_FLAG_C_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 ext)</description>
            </field>
            <field>
              <name>MASKED_IPCX2EXT_FLAG_D_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked inter processor communication source interrupt (... 2 ext)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_I2CSL_INTERRUPTS</name>
          <addressOffset>0x0090</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_I2CSL_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked TX buffer not full interrupt.</description>
            </field>
            <field>
              <name>MASKED_I2CSL_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked RX buffer not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_I2CSL_TX_STRETCH_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked TX stretch interrupt.</description>
            </field>
            <field>
              <name>MASKED_I2CSL_START_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked I2C START event occurred interrupt</description>
            </field>
            <field>
              <name>MASKED_I2CSL_STOP_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked I2C STOP event occurred interrupt</description>
            </field>
            <field>
              <name>MASKED_I2CSL_SLAD_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked I2C SLAD event occurred interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_PWMS_INTERRUPTS[0]</name>
          <addressOffset>0x0094</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_PWMS_PWM0_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm0</description>
            </field>
            <field>
              <name>MASKED_PWMS_PWM1_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm1</description>
            </field>
            <field>
              <name>MASKED_PWMS_PWM2_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm2</description>
            </field>
            <field>
              <name>MASKED_PWMS_PWM3_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm3</description>
            </field>
            <field>
              <name>MASKED_PWMS_PWM4_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm4</description>
            </field>
            <field>
              <name>MASKED_PWMS_PWM5_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm5</description>
            </field>
            <field>
              <name>MASKED_PWMS_PWM6_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm6</description>
            </field>
            <field>
              <name>MASKED_PWMS_PWM7_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked PWM threshold_match interrupt of pwm7</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_PWMS_INTERRUPTS[1]</name>
          <addressOffset>0x0095</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_PWMS_NEXT_THRESHOLD_UNDERRUN_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked PWM next threshold underrun interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_NEXT_THRESHOLD_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked PWM next threshold not full interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP_OVERRUN_INTERRUPT</name>
              <bitRange>[5:2]</bitRange>
              <description>masked PWM timestamp overrun interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP0_OVERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked PWM timestamp0 overrun interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP1_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked PWM timestamp1 overrun interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP2_OVERRUN_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked PWM timestamp2 overrun interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP3_OVERRUN_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked PWM timestamp3 overrun interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT[0]</name>
              <bitRange>[7:6]</bitRange>
              <description>masked PWM timestamp not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP0_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked PWM timestamp0 not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP1_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked PWM timestamp1 not empty interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_PWMS_INTERRUPTS[2]</name>
          <addressOffset>0x0096</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_PWMS_TIMESTAMP_NOT_EMPTY_INTERRUPT[1]</name>
              <bitRange>[1:0]</bitRange>
              <description>masked PWM timestamp not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP2_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked PWM timestamp2 not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_PWMS_TIMESTAMP3_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked PWM timestamp3 not empty interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_ADCIF_INTERRUPTS</name>
          <addressOffset>0x0098</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_ADCIF_BUFFER_A_UPDATED_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked buffer a updated interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_BUFFER_B_UPDATED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked buffer b updated interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_BUFFER_C_UPDATED_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked buffer c updated interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_FIFO_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked fifo not empty interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_FIFO_OVERRUN_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked fifo overrun interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_CYCLE_DONE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked cycle done interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_OVERVOLTAGE_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked fifo overvoltage interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_AWD_ABOVE_MAXIMUM_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>masked analog watchdog value above maximum interrupt</description>
            </field>
            <field>
              <name>MASKED_ADCIF_AWD_BELOW_MINIMUM_INTERRUPT</name>
              <bitRange>[8:8]</bitRange>
              <description>masked analog watchdog value below minimum interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_UART_0_INTERRUPTS</name>
          <addressOffset>0x009A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_UART_0_TX_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked TX not busy interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_0_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked TX not full interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_0_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked RX not empty interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_0_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked RX overrun interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_0_RX_PARITY_ERROR_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked RX parity error interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_0_RX_FRAMING_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked RX framing error interrupt.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_UART_1_INTERRUPTS</name>
          <addressOffset>0x009B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_UART_1_TX_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked TX not busy interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_1_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked TX not full interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_1_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked RX not empty interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_1_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked RX overrun interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_1_RX_PARITY_ERROR_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked RX parity error interrupt.</description>
            </field>
            <field>
              <name>MASKED_UART_1_RX_FRAMING_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked RX framing error interrupt.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_TIMERS_INTERRUPTS</name>
          <addressOffset>0x009C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_TIMERS_TMR0_WRAP_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TIMERS_TMR1_WRAP_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TIMERS_TMR2_WRAP_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TIMERS_TMR3_WRAP_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_TIMERS_TMR4_WRAP_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_IR_INTERRUPTS</name>
          <addressOffset>0x009D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_IR_SEQUENCE_START_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_IR_SEQUENCE_REPEAT_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_IR_SEQUENCE_DONE_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_IR_INDEX_MATCH_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_ASP_INTERRUPTS</name>
          <addressOffset>0x009E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_ASP_DATASTREAM_0_VALID_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_ASP_DATASTREAM_1_VALID_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_I2SM_INTERRUPTS</name>
          <addressOffset>0x009F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_I2SM_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_I2SM_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_BBPLL_INTERRUPTS</name>
          <addressOffset>0x00A0</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_BBPLL_COARSE_OUT_OF_RANGE_HI_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_COARSE_OUT_OF_RANGE_LO_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_TUNE_OUT_OF_RANGE_HI_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_TUNE_OUT_OF_RANGE_LO_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_FREQ_OUT_OF_RANGE_HI_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_FREQ_OUT_OF_RANGE_LO_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_FREQ_OUT_OF_RANGE_TIMEOUT_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_IN_LOCK_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>MASKED_BBPLL_OUT_OF_LOCK_INTERRUPT</name>
              <bitRange>[8:8]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_SECPROC_INTERRUPTS</name>
          <addressOffset>0x00A2</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_SECPROC_CRYPTO_MASTER_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked interrupt triggered by the CryptoMaster submodule, i.e. the symmetric cryptographic operations engine</description>
            </field>
            <field>
              <name>MASKED_SECPROC_TRNG_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked interrupt triggered by the NDRNG submodule, i.e. the Non-Deterministic Random Number Generator</description>
            </field>
            <field>
              <name>MASKED_SECPROC_PKE_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked interrupt triggered by the Public Key submodule, i.e. the asymmetric cryptographic operations engine</description>
            </field>
            <field>
              <name>MASKED_SECPROC_ERR_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked interrupt triggered when the internal DMA runs into a memory bus error</description>
            </field>
          </fields>
        </register>

        <register>
          <name>INT_CTRL_MASKED_SINGLE_INTERRUPTS</name>
          <addressOffset>0x00A3</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>MASKED_PARFCS_LEVEL_TRIGGER_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>masked triggering an interrupt when n bytes were received</description>
            </field>
            <field>
              <name>MASKED_MRI_ACCESS_DONE_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>masked mri write interrupt</description>
            </field>
            <field>
              <name>MASKED_GPMICRO_MEM_EXCEPTION_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>masked mem exception of gpmicro interrupt.</description>
            </field>
            <field>
              <name>MASKED_WATCHDOG_TIMER_EXPIRED_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>masked watchdog timer expired interrupt</description>
            </field>
            <field>
              <name>MASKED_SSP_DONE_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>masked ssp done interrupt</description>
            </field>
            <field>
              <name>MASKED_RPA_DONE_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>masked rpa done interrupt</description>
            </field>
            <field>
              <name>MASKED_KEYPAD_SCAN_DONE_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>masked keypad scan done interrupt</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>CORTEXM4</name>
      <baseAddress>0x40000C40</baseAddress>
      <registers>
        <register>
          <name>CORTEXM4_0X00000000[0]</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>VECTOR_TABLE_OFFSET[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Offset in 256 byte multiples for the vector table</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000000[1]</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000080</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>VECTOR_TABLE_OFFSET[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Offset in 256 byte multiples for the vector table</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000000[2]</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000004</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>VECTOR_TABLE_OFFSET[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>Offset in 256 byte multiples for the vector table</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000004[0]</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SYSTICK_CALIB[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Should be set to the value in order to a 10 ms delay from the FCLK. So needs to change when FCLK changes frequency</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000004[1]</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000071</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SYSTICK_CALIB[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Should be set to the value in order to a 10 ms delay from the FCLK. So needs to change when FCLK changes frequency</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000004[2]</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000002</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SYSTICK_CALIB[2]</name>
              <bitRange>[7:0]</bitRange>
              <description>Should be set to the value in order to a 10 ms delay from the FCLK. So needs to change when FCLK changes frequency</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000007</name>
          <addressOffset>0x0007</addressOffset>
          <size>8</size>
          <resetValue>0x00000007</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>JTAG_NTRST</name>
              <bitRange>[0:0]</bitRange>
              <description>TRSTn pin for the JTAG interface</description>
            </field>
            <field>
              <name>SYSRESET_WHEN_LOCKUP</name>
              <bitRange>[1:1]</bitRange>
              <description>This enables the sysreset on lockup feature. So when a lockup happens, this will trigger a system reset</description>
            </field>
            <field>
              <name>DO_SOFT_POR_ON_SYSRESETREQ</name>
              <bitRange>[2:2]</bitRange>
              <description>When set, a sysreset req (triggered from debug interface, will trigger a soft por (POR_REASON_SOFT_POR_PRESERVE_DBG_ITF)</description>
            </field>
            <field>
              <name>DISABLE_FCLK_GATING</name>
              <bitRange>[3:3]</bitRange>
              <description>by default fclk is also gated - this bit allows fdor disabling this clk gating feature - REQUIRED when ENABLING DEBUG INTERFACE !</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000008</name>
          <addressOffset>0x0008</addressOffset>
          <size>16</size>
          <resetValue>0x00001A08</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ICODE_DCODE_BLOCK_0_REMAP</name>
              <bitRange>[2:0]</bitRange>
              <description>logical to physical block remapping on dcode and icode mem interface for block 0 (allowed values 0 to 3, bit 2 is reserved)</description>
            </field>
            <field>
              <name>ICODE_DCODE_BLOCK_1_REMAP</name>
              <bitRange>[5:3]</bitRange>
              <description>logical to physical block remapping on dcode and icode mem interface for block 1 (allowed values 0 to 3, bit 2 is reserved)</description>
            </field>
            <field>
              <name>ICODE_DCODE_BLOCK_2_REMAP</name>
              <bitRange>[10:8]</bitRange>
              <description>logical to physical block remapping on dcode and icode mem interface for block 2 (allowed values 0 to 3, bit 2 is reserved)</description>
            </field>
            <field>
              <name>ICODE_DCODE_BLOCK_3_REMAP</name>
              <bitRange>[13:11]</bitRange>
              <description>logical to physical block remapping on dcode and icode mem interface for block 3 (allowed values 0 to 3, bit 2 is reserved)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X0000000C</name>
          <addressOffset>0x000C</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>FLASH_VIRT_WINDOW_0_OFFSET</name>
              <bitRange>[7:0]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 0 into the main flash array</description>
            </field>
            <field>
              <name>FLASH_VIRT_WINDOW_1_OFFSET</name>
              <bitRange>[15:8]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 1 into the main flash array</description>
            </field>
            <field>
              <name>FLASH_VIRT_WINDOW_2_OFFSET</name>
              <bitRange>[23:16]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 2 into the main flash array</description>
            </field>
            <field>
              <name>FLASH_VIRT_WINDOW_3_OFFSET</name>
              <bitRange>[31:24]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 3 into the main flash array</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000010</name>
          <addressOffset>0x0010</addressOffset>
          <size>32</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>FLASH_VIRT_WINDOW_4_OFFSET</name>
              <bitRange>[7:0]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 4 into the main flash array</description>
            </field>
            <field>
              <name>FLASH_VIRT_WINDOW_5_OFFSET</name>
              <bitRange>[15:8]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 5 into the main flash array</description>
            </field>
            <field>
              <name>FLASH_VIRT_WINDOW_6_OFFSET</name>
              <bitRange>[23:16]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 6 into the main flash array</description>
            </field>
            <field>
              <name>FLASH_VIRT_WINDOW_7_OFFSET</name>
              <bitRange>[31:24]</bitRange>
              <description>offset redirecting the 4kB virtual icode/dcode flash window 7 into the main flash array</description>
            </field>
          </fields>
        </register>

        <register>
          <name>CORTEXM4_0X00000015</name>
          <addressOffset>0x0015</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>ASLEEP</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates that the processor is in sleep mode</description>
            </field>
            <field>
              <name>INDEEPSLEEP</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the processor is in deep sleep mode</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>GPIO</name>
      <baseAddress>0x40001000</baseAddress>
      <registers>
        <register>
          <name>GPIO_GPIO_CLOCK_ENABLE</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO_CLOCK_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Gpio clock enabled when 0x1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTA_DIRECTION</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO0_DIRECTION</name>
              <bitRange>[0:0]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO1_DIRECTION</name>
              <bitRange>[1:1]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO2_DIRECTION</name>
              <bitRange>[2:2]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO3_DIRECTION</name>
              <bitRange>[3:3]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO4_DIRECTION</name>
              <bitRange>[4:4]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO5_DIRECTION</name>
              <bitRange>[5:5]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO6_DIRECTION</name>
              <bitRange>[6:6]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO7_DIRECTION</name>
              <bitRange>[7:7]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTB_DIRECTION</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO8_DIRECTION</name>
              <bitRange>[0:0]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO9_DIRECTION</name>
              <bitRange>[1:1]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO10_DIRECTION</name>
              <bitRange>[2:2]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO11_DIRECTION</name>
              <bitRange>[3:3]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO12_DIRECTION</name>
              <bitRange>[4:4]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO13_DIRECTION</name>
              <bitRange>[5:5]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO14_DIRECTION</name>
              <bitRange>[6:6]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO15_DIRECTION</name>
              <bitRange>[7:7]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTC_DIRECTION</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO16_DIRECTION</name>
              <bitRange>[0:0]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO17_DIRECTION</name>
              <bitRange>[1:1]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO18_DIRECTION</name>
              <bitRange>[2:2]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO19_DIRECTION</name>
              <bitRange>[3:3]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO20_DIRECTION</name>
              <bitRange>[4:4]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO21_DIRECTION</name>
              <bitRange>[5:5]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
            <field>
              <name>GPIO22_DIRECTION</name>
              <bitRange>[6:6]</bitRange>
              <description>0 = input, 1 = output</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTA_OUTPUT_VALUE</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO0_OUTPUT_VALUE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO1_OUTPUT_VALUE</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO2_OUTPUT_VALUE</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO3_OUTPUT_VALUE</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO4_OUTPUT_VALUE</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO5_OUTPUT_VALUE</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO6_OUTPUT_VALUE</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO7_OUTPUT_VALUE</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTB_OUTPUT_VALUE</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO8_OUTPUT_VALUE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO9_OUTPUT_VALUE</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO10_OUTPUT_VALUE</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO11_OUTPUT_VALUE</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO12_OUTPUT_VALUE</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO13_OUTPUT_VALUE</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO14_OUTPUT_VALUE</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO15_OUTPUT_VALUE</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTC_OUTPUT_VALUE</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIO16_OUTPUT_VALUE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO17_OUTPUT_VALUE</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO18_OUTPUT_VALUE</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO19_OUTPUT_VALUE</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO20_OUTPUT_VALUE</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO21_OUTPUT_VALUE</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO22_OUTPUT_VALUE</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTA_INPUT_VALUE</name>
          <addressOffset>0x0007</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>GPIO0_INPUT_VALUE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO1_INPUT_VALUE</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO2_INPUT_VALUE</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO3_INPUT_VALUE</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO4_INPUT_VALUE</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO5_INPUT_VALUE</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO6_INPUT_VALUE</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO7_INPUT_VALUE</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTB_INPUT_VALUE</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>GPIO8_INPUT_VALUE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO9_INPUT_VALUE</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO10_INPUT_VALUE</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO11_INPUT_VALUE</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO12_INPUT_VALUE</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO13_INPUT_VALUE</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO14_INPUT_VALUE</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO15_INPUT_VALUE</name>
              <bitRange>[7:7]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_GPIO_PORTC_INPUT_VALUE</name>
          <addressOffset>0x0009</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>GPIO16_INPUT_VALUE</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO17_INPUT_VALUE</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO18_INPUT_VALUE</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO19_INPUT_VALUE</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO20_INPUT_VALUE</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO21_INPUT_VALUE</name>
              <bitRange>[5:5]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>GPIO22_INPUT_VALUE</name>
              <bitRange>[6:6]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_EXTI_PORT_SEL</name>
          <addressOffset>0x000A</addressOffset>
          <size>16</size>
          <resetValue>0x00005555</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>EXTI0_PORT_SEL</name>
              <bitRange>[1:0]</bitRange>
              <description>Select the correct port for the exti0 interrupt</description>
            </field>
            <field>
              <name>EXTI1_PORT_SEL</name>
              <bitRange>[3:2]</bitRange>
              <description>Select the correct port for the exti1 interrupt</description>
            </field>
            <field>
              <name>EXTI2_PORT_SEL</name>
              <bitRange>[5:4]</bitRange>
              <description>Select the correct port for the exti2 interrupt</description>
            </field>
            <field>
              <name>EXTI3_PORT_SEL</name>
              <bitRange>[7:6]</bitRange>
              <description>Select the correct port for the exti3 interrupt</description>
            </field>
            <field>
              <name>EXTI4_PORT_SEL</name>
              <bitRange>[9:8]</bitRange>
              <description>Select the correct port for the exti4 interrupt</description>
            </field>
            <field>
              <name>EXTI5_PORT_SEL</name>
              <bitRange>[11:10]</bitRange>
              <description>Select the correct port for the exti5 interrupt</description>
            </field>
            <field>
              <name>EXTI6_PORT_SEL</name>
              <bitRange>[13:12]</bitRange>
              <description>Select the correct port for the exti6 interrupt</description>
            </field>
            <field>
              <name>EXTI7_PORT_SEL</name>
              <bitRange>[15:14]</bitRange>
              <description>Select the correct port for the exti7 interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_EXTI_EXPECTED_VALUE</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>EXTI0_EXPECTED_VALUE</name>
              <bitRange>[0:0]</bitRange>
              <description>Expected value for the pin associated with exti0 interrupt</description>
            </field>
            <field>
              <name>EXTI1_EXPECTED_VALUE</name>
              <bitRange>[1:1]</bitRange>
              <description>Expected value for the pin associated with exti1 interrupt</description>
            </field>
            <field>
              <name>EXTI2_EXPECTED_VALUE</name>
              <bitRange>[2:2]</bitRange>
              <description>Expected value for the pin associated with exti2 interrupt</description>
            </field>
            <field>
              <name>EXTI3_EXPECTED_VALUE</name>
              <bitRange>[3:3]</bitRange>
              <description>Expected value for the pin associated with exti3 interrupt</description>
            </field>
            <field>
              <name>EXTI4_EXPECTED_VALUE</name>
              <bitRange>[4:4]</bitRange>
              <description>Expected value for the pin associated with exti4 interrupt</description>
            </field>
            <field>
              <name>EXTI5_EXPECTED_VALUE</name>
              <bitRange>[5:5]</bitRange>
              <description>Expected value for the pin associated with exti5 interrupt</description>
            </field>
            <field>
              <name>EXTI6_EXPECTED_VALUE</name>
              <bitRange>[6:6]</bitRange>
              <description>Expected value for the pin associated with exti6 interrupt</description>
            </field>
            <field>
              <name>EXTI7_EXPECTED_VALUE</name>
              <bitRange>[7:7]</bitRange>
              <description>Expected value for the pin associated with exti7 interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>GPIO_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_EXTI_INTERRUPTS</name>
              <bitRange>[7:0]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI2_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI3_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI4_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI5_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI6_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
            <field>
              <name>UNMASKED_EXTI7_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>Unmasked Interrupt event, set to 0x1 when detected</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>I2C_M</name>
      <baseAddress>0x40001020</baseAddress>
      <registers>
        <register>
          <name>I2C_M_PRESCALER</name>
          <addressOffset>0x0000</addressOffset>
          <size>16</size>
          <resetValue>0x0000FFFF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRESCALER</name>
              <bitRange>[15:0]</bitRange>
              <description>None</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2C_M_CONFIG</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable core when &amp;apos;1&amp;apos; : en has to be put to &amp;apos;0&amp;apos; when a new prescaler value is loaded</description>
            </field>
            <field>
              <name>ACK</name>
              <bitRange>[1:1]</bitRange>
              <description>ACK to be transmitted</description>
            </field>
            <field>
              <name>CLK_SYNC_DISABLE</name>
              <bitRange>[2:2]</bitRange>
              <description>Disable clock synchronization slave wait detection</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2C_M_TX_DATA</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TX_DATA</name>
              <bitRange>[7:0]</bitRange>
              <description>Byte to be transferred</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2C_M_RX_DATA</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>RX_DATA</name>
              <bitRange>[7:0]</bitRange>
              <description>Byte received</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2C_M_STATUS</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>READ_WRITE_BUSY</name>
              <bitRange>[0:0]</bitRange>
              <description>Byte Read or Byte Write in progress</description>
            </field>
            <field>
              <name>TRANSFER_BUSY</name>
              <bitRange>[1:1]</bitRange>
              <description>Data Transfer in progress (between start and stop condition)</description>
            </field>
            <field>
              <name>RX_ACK</name>
              <bitRange>[2:2]</bitRange>
              <description>ACK from slave received</description>
            </field>
            <field>
              <name>CLK_SYNC</name>
              <bitRange>[3:3]</bitRange>
              <description>Clock Synchornization Slave Wait</description>
            </field>
            <field>
              <name>UNMASKED_DONE_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Unmasked Done Interrupt</description>
            </field>
            <field>
              <name>UNMASKED_ARB_LOST_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Unmasked Arbitration Lost Interrupt</description>
            </field>
            <field>
              <name>UNMASKED_CLK_SYNC_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>Unmasked Clock Synchronization Slave Wait Interrupt</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>ADCIF</name>
      <baseAddress>0x40001040</baseAddress>
      <registers>
        <register>
          <name>ADCIF_GENERAL_CONFIG[0]</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIGGER_MODE</name>
              <bitRange>[2:0]</bitRange>
              <description>Defines when the adc measurement is triggered - see enum for possibilities</description>
            </field>
            <field>
              <name>ENABLE</name>
              <bitRange>[3:3]</bitRange>
              <description>Enables the adc to perform measurements</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_GENERAL_CONFIG[1]</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>NBR_OF_SLOTS_IN_CYCLE</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the number of slots that are used in a measurement cycle. Up to 4 slots can be used, resulting in an way to measure 4 different channels per cycle. This setting specifies the number of slots-1 (so setting 0 -&amp;gt; 1 slot, setting 3 -&amp;gt; 4 slots)</description>
            </field>
            <field>
              <name>NBR_OF_REJECTED_SWAP_CONV</name>
              <bitRange>[3:2]</bitRange>
              <description>Sets the number of conversions that are rejected in a chopped measurement after changing the adc swap input</description>
            </field>
            <field>
              <name>NBR_OF_REJECTED_CONVERSIONS</name>
              <bitRange>[7:4]</bitRange>
              <description>Sets the number of conversions that are rejected between 2 measurements on different channels - acoounts for channel select mux settling time</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_GENERAL_CONFIG[2]</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>USE_FRACT_CLOCK_AS_SAMPLE_CLK_SOURCE</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, the clock that is sent to the analog domain is coming from the fractional clock generator (needs bbpll to be on). If not set the clock is a 4MHz 50pct duty cycle clock</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_A_CONFIG[0]</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_A_CHANNEL</name>
              <bitRange>[3:0]</bitRange>
              <description>The adc channel for slot a</description>
            </field>
            <field>
              <name>SLOT_A_POST_TO_BUFFER_A</name>
              <bitRange>[4:4]</bitRange>
              <description>post result to first result buffer</description>
            </field>
            <field>
              <name>SLOT_A_POST_TO_BUFFER_B</name>
              <bitRange>[5:5]</bitRange>
              <description>post result to second result buffer</description>
            </field>
            <field>
              <name>SLOT_A_POST_TO_BUFFER_C</name>
              <bitRange>[6:6]</bitRange>
              <description>post result to third result buffer</description>
            </field>
            <field>
              <name>SLOT_A_POST_TO_FIFO</name>
              <bitRange>[7:7]</bitRange>
              <description>post result to result fifo</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_A_CONFIG[1]</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000080</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_A_POST_TO_AWD</name>
              <bitRange>[0:0]</bitRange>
              <description>post result to analog watchdog</description>
            </field>
            <field>
              <name>SLOT_A_SCALER_GAIN</name>
              <bitRange>[3:1]</bitRange>
              <description>gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this.</description>
            </field>
            <field>
              <name>SLOT_A_CHOPPING_ENABLED</name>
              <bitRange>[4:4]</bitRange>
              <description>idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path</description>
            </field>
            <field>
              <name>SLOT_A_DIFFERENTIAL_MODE</name>
              <bitRange>[5:5]</bitRange>
              <description>idicates whether we want to do a single_ended or differential measurement</description>
            </field>
            <field>
              <name>SLOT_A_SCALER_BIAS_CC_PUP</name>
              <bitRange>[6:6]</bitRange>
              <description>constant current pup</description>
            </field>
            <field>
              <name>SLOT_A_SCALER_BIAS_CGM_PUP</name>
              <bitRange>[7:7]</bitRange>
              <description>constant gm pup</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_A_CONFIG[2]</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_A_SMUX_ADC_BUF_N_BYPASS</name>
              <bitRange>[0:0]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for n-input adc</description>
            </field>
            <field>
              <name>SLOT_A_SMUX_ADC_BUF_P_BYPASS</name>
              <bitRange>[1:1]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for p-input adc</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_B_CONFIG[0]</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_B_CHANNEL</name>
              <bitRange>[3:0]</bitRange>
              <description>The adc channel for slot b</description>
            </field>
            <field>
              <name>SLOT_B_POST_TO_BUFFER_A</name>
              <bitRange>[4:4]</bitRange>
              <description>post result to first result buffer</description>
            </field>
            <field>
              <name>SLOT_B_POST_TO_BUFFER_B</name>
              <bitRange>[5:5]</bitRange>
              <description>post result to second result buffer</description>
            </field>
            <field>
              <name>SLOT_B_POST_TO_BUFFER_C</name>
              <bitRange>[6:6]</bitRange>
              <description>post result to third result buffer</description>
            </field>
            <field>
              <name>SLOT_B_POST_TO_FIFO</name>
              <bitRange>[7:7]</bitRange>
              <description>post result to result fifo</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_B_CONFIG[1]</name>
          <addressOffset>0x0009</addressOffset>
          <size>8</size>
          <resetValue>0x00000080</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_B_POST_TO_AWD</name>
              <bitRange>[0:0]</bitRange>
              <description>post result to analog watchdog</description>
            </field>
            <field>
              <name>SLOT_B_SCALER_GAIN</name>
              <bitRange>[3:1]</bitRange>
              <description>gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this.</description>
            </field>
            <field>
              <name>SLOT_B_CHOPPING_ENABLED</name>
              <bitRange>[4:4]</bitRange>
              <description>idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path</description>
            </field>
            <field>
              <name>SLOT_B_DIFFERENTIAL_MODE</name>
              <bitRange>[5:5]</bitRange>
              <description>idicates whether we want to do a single_ended or differential measurement</description>
            </field>
            <field>
              <name>SLOT_B_SCALER_BIAS_CC_PUP</name>
              <bitRange>[6:6]</bitRange>
              <description>constant current pup</description>
            </field>
            <field>
              <name>SLOT_B_SCALER_BIAS_CGM_PUP</name>
              <bitRange>[7:7]</bitRange>
              <description>constant gm pup</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_B_CONFIG[2]</name>
          <addressOffset>0x000A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_B_SMUX_ADC_BUF_N_BYPASS</name>
              <bitRange>[0:0]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for n-input adc</description>
            </field>
            <field>
              <name>SLOT_B_SMUX_ADC_BUF_P_BYPASS</name>
              <bitRange>[1:1]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for p-input adc</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_C_CONFIG[0]</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_C_CHANNEL</name>
              <bitRange>[3:0]</bitRange>
              <description>The adc channel for slot c</description>
            </field>
            <field>
              <name>SLOT_C_POST_TO_BUFFER_A</name>
              <bitRange>[4:4]</bitRange>
              <description>post result to first result buffer</description>
            </field>
            <field>
              <name>SLOT_C_POST_TO_BUFFER_B</name>
              <bitRange>[5:5]</bitRange>
              <description>post result to second result buffer</description>
            </field>
            <field>
              <name>SLOT_C_POST_TO_BUFFER_C</name>
              <bitRange>[6:6]</bitRange>
              <description>post result to third result buffer</description>
            </field>
            <field>
              <name>SLOT_C_POST_TO_FIFO</name>
              <bitRange>[7:7]</bitRange>
              <description>post result to result fifo</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_C_CONFIG[1]</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x00000080</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_C_POST_TO_AWD</name>
              <bitRange>[0:0]</bitRange>
              <description>post result to analog watchdog</description>
            </field>
            <field>
              <name>SLOT_C_SCALER_GAIN</name>
              <bitRange>[3:1]</bitRange>
              <description>gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this.</description>
            </field>
            <field>
              <name>SLOT_C_CHOPPING_ENABLED</name>
              <bitRange>[4:4]</bitRange>
              <description>idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path</description>
            </field>
            <field>
              <name>SLOT_C_DIFFERENTIAL_MODE</name>
              <bitRange>[5:5]</bitRange>
              <description>idicates whether we want to do a single_ended or differential measurement</description>
            </field>
            <field>
              <name>SLOT_C_SCALER_BIAS_CC_PUP</name>
              <bitRange>[6:6]</bitRange>
              <description>constant current pup</description>
            </field>
            <field>
              <name>SLOT_C_SCALER_BIAS_CGM_PUP</name>
              <bitRange>[7:7]</bitRange>
              <description>constant gm pup</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_C_CONFIG[2]</name>
          <addressOffset>0x000E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_C_SMUX_ADC_BUF_N_BYPASS</name>
              <bitRange>[0:0]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for n-input adc</description>
            </field>
            <field>
              <name>SLOT_C_SMUX_ADC_BUF_P_BYPASS</name>
              <bitRange>[1:1]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for p-input adc</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_D_CONFIG[0]</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_D_CHANNEL</name>
              <bitRange>[3:0]</bitRange>
              <description>The adc channel for slot d</description>
            </field>
            <field>
              <name>SLOT_D_POST_TO_BUFFER_A</name>
              <bitRange>[4:4]</bitRange>
              <description>post result to first result buffer</description>
            </field>
            <field>
              <name>SLOT_D_POST_TO_BUFFER_B</name>
              <bitRange>[5:5]</bitRange>
              <description>post result to second result buffer</description>
            </field>
            <field>
              <name>SLOT_D_POST_TO_BUFFER_C</name>
              <bitRange>[6:6]</bitRange>
              <description>post result to third result buffer</description>
            </field>
            <field>
              <name>SLOT_D_POST_TO_FIFO</name>
              <bitRange>[7:7]</bitRange>
              <description>post result to result fifo</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_D_CONFIG[1]</name>
          <addressOffset>0x0011</addressOffset>
          <size>8</size>
          <resetValue>0x00000080</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_D_POST_TO_AWD</name>
              <bitRange>[0:0]</bitRange>
              <description>post result to analog watchdog</description>
            </field>
            <field>
              <name>SLOT_D_SCALER_GAIN</name>
              <bitRange>[3:1]</bitRange>
              <description>gain to use on the input, note that this is differential gain. Single ended to differential gain will be half of this.</description>
            </field>
            <field>
              <name>SLOT_D_CHOPPING_ENABLED</name>
              <bitRange>[4:4]</bitRange>
              <description>idicates whether we want to do a chopped measurement to cancel out offset errors in the signal path</description>
            </field>
            <field>
              <name>SLOT_D_DIFFERENTIAL_MODE</name>
              <bitRange>[5:5]</bitRange>
              <description>idicates whether we want to do a single_ended or differential measurement</description>
            </field>
            <field>
              <name>SLOT_D_SCALER_BIAS_CC_PUP</name>
              <bitRange>[6:6]</bitRange>
              <description>constant current pup</description>
            </field>
            <field>
              <name>SLOT_D_SCALER_BIAS_CGM_PUP</name>
              <bitRange>[7:7]</bitRange>
              <description>constant gm pup</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_SLOT_D_CONFIG[2]</name>
          <addressOffset>0x0012</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLOT_D_SMUX_ADC_BUF_N_BYPASS</name>
              <bitRange>[0:0]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for n-input adc</description>
            </field>
            <field>
              <name>SLOT_D_SMUX_ADC_BUF_P_BYPASS</name>
              <bitRange>[1:1]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for p-input adc</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_PRESET_MAX_VALUE</name>
          <addressOffset>0x0014</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRESET_MAX_VALUE</name>
              <bitRange>[9:0]</bitRange>
              <description>This is the value that is used to preset the awd/buffer_a/b/c maximal value when buffer_a_preset / buffer_b_preset / buffer_c_preset / awd_preset is applied</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_PRESET_MIN_VALUE</name>
          <addressOffset>0x0016</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRESET_MIN_VALUE</name>
              <bitRange>[9:0]</bitRange>
              <description>This is the value that is used to preset the awd/buffer_a/b/c minimal value when buffer_a_preset / buffer_b_preset / buffer_c_preset / awd_preset is applied</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_MAILBOX_CONFIG</name>
          <addressOffset>0x0018</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>FIFO_SUBSAMPLE_RATE</name>
              <bitRange>[2:0]</bitRange>
              <description>Defines the rate at which samples are put into the fifo (every fifo_subsample_rate+1 &amp;apos;th sample is used)</description>
            </field>
            <field>
              <name>FIFO_MODE8BITS</name>
              <bitRange>[3:3]</bitRange>
              <description>Puts fifo in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of fifo</description>
            </field>
            <field>
              <name>BUFFER_A_MODE8BITS</name>
              <bitRange>[4:4]</bitRange>
              <description>Puts buffer a in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_a</description>
            </field>
            <field>
              <name>BUFFER_A_UPDATE_MODE</name>
              <bitRange>[6:5]</bitRange>
              <description>Sets the update mode of buffer a (normal, minimum hold, maximum hold or out-of-range mode)</description>
            </field>
            <field>
              <name>BUFFER_B_MODE8BITS</name>
              <bitRange>[7:7]</bitRange>
              <description>Puts buffer b in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_b</description>
            </field>
            <field>
              <name>BUFFER_B_UPDATE_MODE</name>
              <bitRange>[9:8]</bitRange>
              <description>Sets the update mode of buffer b (normal, minimum hold, maximum hold or out-of-range mode)</description>
            </field>
            <field>
              <name>BUFFER_C_MODE8BITS</name>
              <bitRange>[10:10]</bitRange>
              <description>Puts buffer c in 8 bits mode (iso 10 bits mode) - the result is in the LSB bits of buffer_c</description>
            </field>
            <field>
              <name>BUFFER_C_UPDATE_MODE</name>
              <bitRange>[12:11]</bitRange>
              <description>Sets the update mode of buffer c (normal, minimum hold, maximum hold or out-of-range mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_BUFFER_A_RESULT_PB</name>
          <addressOffset>0x001E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>BUFFER_A_RESULT_0</name>
              <bitRange>[7:0]</bitRange>
              <description>LSB bits of the result buffer a</description>
            </field>
            <field>
              <name>BUFFER_A_RESULT</name>
              <bitRange>[9:0]</bitRange>
              <description>result buffer a</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_BUFFER_B_RESULT_PB</name>
          <addressOffset>0x0020</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>BUFFER_B_RESULT_0</name>
              <bitRange>[7:0]</bitRange>
              <description>LSB bits of the result buffer b</description>
            </field>
            <field>
              <name>BUFFER_B_RESULT</name>
              <bitRange>[9:0]</bitRange>
              <description>result buffer b</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_BUFFER_C_RESULT_PB</name>
          <addressOffset>0x0022</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>BUFFER_C_RESULT_0</name>
              <bitRange>[7:0]</bitRange>
              <description>LSB bits of the result buffer c</description>
            </field>
            <field>
              <name>BUFFER_C_RESULT</name>
              <bitRange>[9:0]</bitRange>
              <description>result buffer c</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_ANA_FORCE</name>
          <addressOffset>0x0024</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SMUX_CROSS_INVERT</name>
              <bitRange>[0:0]</bitRange>
              <description>makes it able to invert the generated swap signal.</description>
            </field>
            <field>
              <name>SMUX_TSENSOR_SWAP_INPUT_INVERT</name>
              <bitRange>[1:1]</bitRange>
              <description>makes it able to invert the generated swap signal.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_GENERAL_STATUS</name>
          <addressOffset>0x0025</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>EOC_COUNTER_VALUE</name>
              <bitRange>[3:0]</bitRange>
              <description>The current value of the end of conversion counter</description>
            </field>
            <field>
              <name>ACTIVE_SLOT_IDX</name>
              <bitRange>[5:4]</bitRange>
              <description>The slot index of the currently active slot</description>
            </field>
            <field>
              <name>CONVERSION_CYCLE_BUSY</name>
              <bitRange>[6:6]</bitRange>
              <description>Indicates that a conversion is ongoing</description>
            </field>
            <field>
              <name>ADC_CLAMP_ACTIVE</name>
              <bitRange>[7:7]</bitRange>
              <description>Flag indicating that the voltage at the ADC input is too high</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x0026</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_A_UPDATED_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Interrupt triggered when the value in buffer a updated</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_B_UPDATED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Interrupt triggered when the value in buffer b updated</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_C_UPDATED_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Interrupt triggered when the value in buffer c updated</description>
            </field>
            <field>
              <name>UNMASKED_FIFO_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Interrupts generated when there is data in the FIFO</description>
            </field>
            <field>
              <name>UNMASKED_FIFO_OVERRUN_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Interrupts generated when new data was available while FIFO was full</description>
            </field>
            <field>
              <name>UNMASKED_AWD_BELOW_MINIMUM_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Interrupt triggered when the value is below the configured minimum</description>
            </field>
            <field>
              <name>UNMASKED_AWD_ABOVE_MAXIMUM_INTERRUPT</name>
              <bitRange>[6:6]</bitRange>
              <description>Interrupt triggered when the value is above the configured maximum</description>
            </field>
            <field>
              <name>UNMASKED_CYCLE_DONE_INTERRUPT</name>
              <bitRange>[7:7]</bitRange>
              <description>Interrupts generated when a complete measurement cycle finished</description>
            </field>
            <field>
              <name>UNMASKED_OVERVOLTAGE_INTERRUPT</name>
              <bitRange>[8:8]</bitRange>
              <description>interrupt indicating that the voltage at the ADC input was too high during a measurement</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_0X00000028[0]</name>
          <addressOffset>0x0028</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADC_LDO_REFBITS</name>
              <bitRange>[3:0]</bitRange>
              <description>tuning bits for the gp-adc analogue ldo output voltage</description>
            </field>
            <field>
              <name>ADC_VREF_REFBITS</name>
              <bitRange>[7:4]</bitRange>
              <description>tuning bits for the adc reference ldo output voltage</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_0X00000028[1]</name>
          <addressOffset>0x0029</addressOffset>
          <size>8</size>
          <resetValue>0x00000005</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADC_SCALER_BIAS_CGM_RES</name>
              <bitRange>[1:0]</bitRange>
              <description>set resistor ladder for bias current of constant-gm block</description>
            </field>
            <field>
              <name>ADC_SCALER_VCM_REFBITS</name>
              <bitRange>[3:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_SPARE</name>
              <bitRange>[5:4]</bitRange>
              <description>spare</description>
            </field>
            <field>
              <name>SMUX_RESLOAD</name>
              <bitRange>[7:6]</bitRange>
              <description>2 bits resistive load on testbus:0=900k, 1=300k, 2=100k, 3=33k</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_0X00000028[2]</name>
          <addressOffset>0x002A</addressOffset>
          <size>8</size>
          <resetValue>0x00000051</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADC_CLK_MUX_PUP</name>
              <bitRange>[0:0]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_CLK_SELECT</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_CLK_SPEED</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_COMP_BIAS_BOOST</name>
              <bitRange>[3:3]</bitRange>
              <description>doubles the bias current in the comparator</description>
            </field>
            <field>
              <name>ADC_COMP_BIAS_PUP</name>
              <bitRange>[4:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_LDO_BLEED_OFF</name>
              <bitRange>[5:5]</bitRange>
              <description>disable for the bleed transistor at the gp-adc analogue ldo output</description>
            </field>
            <field>
              <name>ADC_LDO_PUP</name>
              <bitRange>[6:6]</bitRange>
              <description>pup signal for the gp-adc analogue ldo</description>
            </field>
            <field>
              <name>ADC_LDO_RESBYPASS</name>
              <bitRange>[7:7]</bitRange>
              <description>signal to bypass the lpf resistor in the gp-adc analogue ldo</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_0X00000028[3]</name>
          <addressOffset>0x002B</addressOffset>
          <size>8</size>
          <resetValue>0x00000069</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADC_OVP_PUP</name>
              <bitRange>[0:0]</bitRange>
              <description>enables overvoltage detection (previously smux)</description>
            </field>
            <field>
              <name>ADC_SCALER_BYPASS</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_SCALER_FILTER_ENABLE</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_SCALER_PUP</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_TEST_VREF</name>
              <bitRange>[4:4]</bitRange>
              <description>connect reference voltage directly to adc for measuring gain error</description>
            </field>
            <field>
              <name>ADC_VCM_BUF_PUP</name>
              <bitRange>[5:5]</bitRange>
              <description>enable signal for the adc vcm buffer, 1.2v</description>
            </field>
            <field>
              <name>ADC_VREF_BUF_PUP</name>
              <bitRange>[6:6]</bitRange>
              <description>enable signal for the adc vddref buffer</description>
            </field>
            <field>
              <name>ADC_VREF_RESBYPASS</name>
              <bitRange>[7:7]</bitRange>
              <description>signal to bypass the lpf resistor in the adc reference ldo</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_0X00000028[4]</name>
          <addressOffset>0x002C</addressOffset>
          <size>8</size>
          <resetValue>0x0000001A</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SMUX_ADC_BUF_N_FULLSCALE</name>
              <bitRange>[0:0]</bitRange>
              <description>switches unity gain buffer to use full scale (enabling nmos input pair as well) for n-input adc</description>
            </field>
            <field>
              <name>SMUX_ADC_BUF_N_PUP</name>
              <bitRange>[1:1]</bitRange>
              <description>enables unity-gain buffer from bus to adc for n-input adc</description>
            </field>
            <field>
              <name>SMUX_ADC_BUF_P_FULLSCALE</name>
              <bitRange>[2:2]</bitRange>
              <description>switches unity gain buffer to use full scale (enabling nmos input pair as well) for p-input adc</description>
            </field>
            <field>
              <name>SMUX_ADC_BUF_P_PUP</name>
              <bitRange>[3:3]</bitRange>
              <description>enables unity-gain buffer from bus to adc for p-input adc</description>
            </field>
            <field>
              <name>SMUX_ADC_CHANNEL_SEL_PUP</name>
              <bitRange>[4:4]</bitRange>
              <description>enabled any anio to be connected to adc-bus</description>
            </field>
            <field>
              <name>SMUX_EXTERNAL_REFERENCE</name>
              <bitRange>[5:5]</bitRange>
              <description>use</description>
            </field>
            <field>
              <name>SMUX_RESLOAD_EN_N</name>
              <bitRange>[6:6]</bitRange>
              <description>enable resistive load on n-side of testbus</description>
            </field>
            <field>
              <name>SMUX_RESLOAD_EN_P</name>
              <bitRange>[7:7]</bitRange>
              <description>enable resistive load on p-side of testbus</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_0X00000028[5]</name>
          <addressOffset>0x002D</addressOffset>
          <size>8</size>
          <resetValue>0x00000004</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SMUX_SELFTEST_MODE</name>
              <bitRange>[0:0]</bitRange>
              <description>selects either offset or gain mode for internal self test</description>
            </field>
            <field>
              <name>SMUX_TSENSOR_PUP</name>
              <bitRange>[1:1]</bitRange>
              <description>enables temperature sensor</description>
            </field>
            <field>
              <name>XO_CLK_4M_PUP</name>
              <bitRange>[2:2]</bitRange>
              <description>enables the 4 mhz clock to the general purpose adc block</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_ANA_OVERRULE</name>
          <addressOffset>0x002E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SMUX_ADC_CHANNEL_SEL_OVERRULE</name>
              <bitRange>[3:0]</bitRange>
              <description>selects which anio is connected to adc-bus</description>
            </field>
            <field>
              <name>ADC_SCALER_OVERRULE</name>
              <bitRange>[6:4]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_DIFF_MODE_OVERRULE</name>
              <bitRange>[7:7]</bitRange>
              <description>selects differential mode usage =1, otherwise single ended adc input</description>
            </field>
            <field>
              <name>ADC_SCALER_BIAS_CC_PUP_OVERRULE</name>
              <bitRange>[8:8]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_SCALER_BIAS_CGM_PUP_OVERRULE</name>
              <bitRange>[9:9]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_START_CONV_OVERRULE</name>
              <bitRange>[10:10]</bitRange>
              <description>request to do a conversion, 1.2v</description>
            </field>
            <field>
              <name>CLK_ADC_DIG_OVERRULE</name>
              <bitRange>[11:11]</bitRange>
              <description>adc conversion clock connected to synthesizer</description>
            </field>
            <field>
              <name>SMUX_ADC_BUF_N_BYPASS_OVERRULE</name>
              <bitRange>[12:12]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for n-input adc</description>
            </field>
            <field>
              <name>SMUX_ADC_BUF_P_BYPASS_OVERRULE</name>
              <bitRange>[13:13]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for p-input adc</description>
            </field>
            <field>
              <name>SMUX_CROSS_OVERRULE</name>
              <bitRange>[14:14]</bitRange>
              <description>swaps anio connection from p/n to n/p on bus for adc, (differential input of adc). this applies to the inputs: anio[0], anio[1], testbus_ch0, testbus_ch1, testbus_ch2, and vbat.</description>
            </field>
            <field>
              <name>SMUX_TSENSOR_SWAP_INPUT_OVERRULE</name>
              <bitRange>[15:15]</bitRange>
              <description>swaps differential outputs of temperature sensor that go to gp-adc</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ADCIF_ANA_OVERRULE_ENA</name>
          <addressOffset>0x0030</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADC_DIFF_MODE_OVERRULE_ENA</name>
              <bitRange>[0:0]</bitRange>
              <description>selects differential mode usage =1, otherwise single ended adc input</description>
            </field>
            <field>
              <name>ADC_SCALER_OVERRULE_ENA</name>
              <bitRange>[1:1]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_SCALER_BIAS_CC_PUP_OVERRULE_ENA</name>
              <bitRange>[2:2]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_SCALER_BIAS_CGM_PUP_OVERRULE_ENA</name>
              <bitRange>[3:3]</bitRange>
              <description>None</description>
            </field>
            <field>
              <name>ADC_START_CONV_OVERRULE_ENA</name>
              <bitRange>[4:4]</bitRange>
              <description>request to do a conversion, 1.2v</description>
            </field>
            <field>
              <name>CLK_ADC_DIG_OVERRULE_ENA</name>
              <bitRange>[5:5]</bitRange>
              <description>adc conversion clock connected to synthesizer</description>
            </field>
            <field>
              <name>SMUX_ADC_BUF_N_BYPASS_OVERRULE_ENA</name>
              <bitRange>[6:6]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for n-input adc</description>
            </field>
            <field>
              <name>SMUX_ADC_BUF_P_BYPASS_OVERRULE_ENA</name>
              <bitRange>[7:7]</bitRange>
              <description>bypasses the unity gain buffer (buffer will be forced off) for p-input adc</description>
            </field>
            <field>
              <name>SMUX_ADC_CHANNEL_SEL_OVERRULE_ENA</name>
              <bitRange>[8:8]</bitRange>
              <description>selects which anio is connected to adc-bus</description>
            </field>
            <field>
              <name>SMUX_CROSS_OVERRULE_ENA</name>
              <bitRange>[9:9]</bitRange>
              <description>swaps anio connection from p/n to n/p on bus for adc, (differential input of adc). this applies to the inputs: anio[0], anio[1], testbus_ch0, testbus_ch1, testbus_ch2, and vbat.</description>
            </field>
            <field>
              <name>SMUX_TSENSOR_SWAP_INPUT_OVERRULE_ENA</name>
              <bitRange>[10:10]</bitRange>
              <description>swaps differential outputs of temperature sensor that go to gp-adc</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>SSP</name>
      <baseAddress>0x40001080</baseAddress>
      <registers>
        <register>
          <name>SSP_A_PTR[0]</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>A_PTR[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Authentication pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_A_PTR[1]</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>A_PTR[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Authentication pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_A_PTR[2]</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>A_PTR[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>Authentication pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_A_LEN</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>A_LEN</name>
              <bitRange>[7:0]</bitRange>
              <description>Authentication length</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MSG_PTR[0]</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MSG_PTR[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Message in pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MSG_PTR[1]</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MSG_PTR[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Message in pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MSG_PTR[2]</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MSG_PTR[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>Message in pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MSG_LEN</name>
          <addressOffset>0x0007</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MSG_LEN</name>
              <bitRange>[7:0]</bitRange>
              <description>Message length</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MIC_PTR[0]</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MIC_PTR[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Mic pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MIC_PTR[1]</name>
          <addressOffset>0x0009</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MIC_PTR[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Mic pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MIC_PTR[2]</name>
          <addressOffset>0x000A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MIC_PTR[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>Mic pointer</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_KEY_PTR[0]</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_PTR[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>key pointer - for access to secured keys, key pointer has to be a multiple of 16 bytes</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_KEY_PTR[1]</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_PTR[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>key pointer - for access to secured keys, key pointer has to be a multiple of 16 bytes</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_KEY_PTR[2]</name>
          <addressOffset>0x000E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_PTR[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>key pointer - for access to secured keys, key pointer has to be a multiple of 16 bytes</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_KEY_MIC_LEN</name>
          <addressOffset>0x000F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_LEN</name>
              <bitRange>[1:0]</bitRange>
              <description>key length enumerate : &amp;quot;00&amp;quot; = 128 bit key, &amp;quot;01&amp;quot; = 192 bit key, &amp;quot;10&amp;quot; = 256 bit key</description>
            </field>
            <field>
              <name>MIC_LEN</name>
              <bitRange>[5:2]</bitRange>
              <description>Mic length/2 (actual length is the value set by this property multiplied by 2)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MSG_OUT_PTR[0]</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MSG_OUT_PTR[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Pointer to destination location for encrypted data</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MSG_OUT_PTR[1]</name>
          <addressOffset>0x0011</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MSG_OUT_PTR[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Pointer to destination location for encrypted data</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MSG_OUT_PTR[2]</name>
          <addressOffset>0x0012</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MSG_OUT_PTR[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>Pointer to destination location for encrypted data</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_NONCE_PTR[0]</name>
          <addressOffset>0x0014</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>NONCE_PTR[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Pointer to destination location for encrypted data</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_NONCE_PTR[1]</name>
          <addressOffset>0x0015</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>NONCE_PTR[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Pointer to destination location for encrypted data</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_NONCE_PTR[2]</name>
          <addressOffset>0x0016</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>NONCE_PTR[2]</name>
              <bitRange>[6:0]</bitRange>
              <description>Pointer to destination location for encrypted data</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_MODE_AND_INT_CONTROL</name>
          <addressOffset>0x0017</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MODE</name>
              <bitRange>[1:0]</bitRange>
              <description>&amp;quot;00&amp;quot; = Encryption, &amp;quot;01&amp;quot; = decryption, &amp;quot;10&amp;quot; = aes mode, &amp;quot;11&amp;quot; = reserved</description>
            </field>
            <field>
              <name>USE_SKEY</name>
              <bitRange>[2:2]</bitRange>
              <description>uses internal secret key  when &amp;apos;1&amp;apos;</description>
            </field>
            <field>
              <name>AES_MMO</name>
              <bitRange>[3:3]</bitRange>
              <description>when set the engine is set into aes_mmo mode - only affects aes_mode</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_CUSTOM_AES_CONTROL</name>
          <addressOffset>0x0018</addressOffset>
          <size>8</size>
          <resetValue>0x00000012</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CUSTOM_AES_MODE_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>enables to override the standard aes sequence and define the number of rounds. When enabled, secure key access is disabled</description>
            </field>
            <field>
              <name>CUSTOM_AES_ROUNDS</name>
              <bitRange>[4:1]</bitRange>
              <description>standard value for key_len 128 = 9, kay_len 192 = 10, key_len 256 = 12. When set differently, aes operation will be non-standard</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SSP_ENCRYPTION_STATUS</name>
          <addressOffset>0x001A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>BUSY</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates the encryption cycle is running</description>
            </field>
            <field>
              <name>MEM_ERR</name>
              <bitRange>[1:1]</bitRange>
              <description>Set when an error occurred while accessing the memory</description>
            </field>
            <field>
              <name>UNMASKED_DONE_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Unmasked interrupt indicating encryption cycle finished</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>UART_0</name>
      <baseAddress>0x400010A0</baseAddress>
      <registers>
        <register>
          <name>UART_0_BAUD_RATE</name>
          <addressOffset>0x0004</addressOffset>
          <size>16</size>
          <resetValue>0x00000022</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BAUD_RATE</name>
              <bitRange>[11:0]</bitRange>
              <description>Actual baud rate = 16MHz / 8*(baud_rate+1)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>UART_0_CONFIG</name>
          <addressOffset>0x0006</addressOffset>
          <size>16</size>
          <resetValue>0x00000227</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA_BITS</name>
              <bitRange>[3:0]</bitRange>
              <description>Number of data bits in an SPI frame - 1 (0x7 = one byte)</description>
            </field>
            <field>
              <name>PARITY</name>
              <bitRange>[5:4]</bitRange>
              <description>Parity bit mode. Controls both the generation for TX and the check for RX.</description>
            </field>
            <field>
              <name>STOP_BITS</name>
              <bitRange>[6:6]</bitRange>
              <description>Number of stop bits - 1 (0x0 = 1, 0x1 = 2. For RX only the first one is checked)</description>
            </field>
            <field>
              <name>USE_SYNC_BIT</name>
              <bitRange>[7:7]</bitRange>
              <description>In case of the HW MSI interface (stream_to_regmap = 0), interpret bit 8 as sync bit to reset internal logic.</description>
            </field>
            <field>
              <name>RX_ENABLE</name>
              <bitRange>[8:8]</bitRange>
              <description>Enable the UART receiver.  (Note the transmitter is automatically enabled when loading data into tx_data)</description>
            </field>
            <field>
              <name>BIT_REVERSE_REPLY</name>
              <bitRange>[9:9]</bitRange>
              <description>In case of the HW MSI interface (stream_to_regmap = 0), bit_reverse the data part of the reply. This feature was added for Lime.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>UART_0_STATUS</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_TX_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Status and unmasked interrupt flag for UART TX not busy. The interrupt is cleared implicitly when writing new TX data. Active when no TX transfer ongoing and no data in TX buffer.</description>
            </field>
            <field>
              <name>UNMASKED_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>UNMASKED_RX_PARITY_ERROR_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a rx parity error. Set when the parity checking is enabled and the received parity bit does not match with the calculated. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>UNMASKED_RX_FRAMING_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a rx framing error. Set when the (first) stop bit of a received frame was not 1. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>RX_NOT_BUSY</name>
              <bitRange>[6:6]</bitRange>
              <description>Status flag for UART RX not busy. Active when no RX transfer is ongoing.</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>UART_1</name>
      <baseAddress>0x400010B0</baseAddress>
      <registers>
        <register>
          <name>UART_1_BAUD_RATE</name>
          <addressOffset>0x0004</addressOffset>
          <size>16</size>
          <resetValue>0x00000022</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BAUD_RATE</name>
              <bitRange>[11:0]</bitRange>
              <description>Actual baud rate = 16MHz / 8*(baud_rate+1)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>UART_1_CONFIG</name>
          <addressOffset>0x0006</addressOffset>
          <size>16</size>
          <resetValue>0x00000227</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA_BITS</name>
              <bitRange>[3:0]</bitRange>
              <description>Number of data bits in an SPI frame - 1 (0x7 = one byte)</description>
            </field>
            <field>
              <name>PARITY</name>
              <bitRange>[5:4]</bitRange>
              <description>Parity bit mode. Controls both the generation for TX and the check for RX.</description>
            </field>
            <field>
              <name>STOP_BITS</name>
              <bitRange>[6:6]</bitRange>
              <description>Number of stop bits - 1 (0x0 = 1, 0x1 = 2. For RX only the first one is checked)</description>
            </field>
            <field>
              <name>USE_SYNC_BIT</name>
              <bitRange>[7:7]</bitRange>
              <description>In case of the HW MSI interface (stream_to_regmap = 0), interpret bit 8 as sync bit to reset internal logic.</description>
            </field>
            <field>
              <name>RX_ENABLE</name>
              <bitRange>[8:8]</bitRange>
              <description>Enable the UART receiver.  (Note the transmitter is automatically enabled when loading data into tx_data)</description>
            </field>
            <field>
              <name>BIT_REVERSE_REPLY</name>
              <bitRange>[9:9]</bitRange>
              <description>In case of the HW MSI interface (stream_to_regmap = 0), bit_reverse the data part of the reply. This feature was added for Lime.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>UART_1_STATUS</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_TX_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Status and unmasked interrupt flag for UART TX not busy. The interrupt is cleared implicitly when writing new TX data. Active when no TX transfer ongoing and no data in TX buffer.</description>
            </field>
            <field>
              <name>UNMASKED_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>UNMASKED_RX_PARITY_ERROR_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a rx parity error. Set when the parity checking is enabled and the received parity bit does not match with the calculated. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>UNMASKED_RX_FRAMING_ERROR_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a rx framing error. Set when the (first) stop bit of a received frame was not 1. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>RX_NOT_BUSY</name>
              <bitRange>[6:6]</bitRange>
              <description>Status flag for UART RX not busy. Active when no RX transfer is ongoing.</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>SPI_M</name>
      <baseAddress>0x400010D0</baseAddress>
      <registers>
        <register>
          <name>SPI_M_CONFIG</name>
          <addressOffset>0x0004</addressOffset>
          <size>16</size>
          <resetValue>0x00000007</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA_BITS</name>
              <bitRange>[3:0]</bitRange>
              <description>Number of data bits in an SPI frame - 1 (0x7 = one byte)</description>
            </field>
            <field>
              <name>SCLK_FREQ</name>
              <bitRange>[6:4]</bitRange>
              <description>SCLK clock frequency: 32MHz / 2**sclk_freq</description>
            </field>
            <field>
              <name>LSB_FIRST</name>
              <bitRange>[7:7]</bitRange>
              <description>Master SPI data order.</description>
            </field>
            <field>
              <name>MODE</name>
              <bitRange>[9:8]</bitRange>
              <description>Master SPI mode</description>
            </field>
            <field>
              <name>FREE_RUNNING</name>
              <bitRange>[10:10]</bitRange>
              <description>Free running mode, spi transfers are back-to-back triggered, even when no new tx_data is provided. Can be used for capturing PDM outputs.</description>
            </field>
            <field>
              <name>STALL_ON_RX_FULL</name>
              <bitRange>[11:11]</bitRange>
              <description>When enabled, a transfer will be stalled (frozen in the last clock cycle of the word) as long as the rx_data FIFO remains full. This will prevent an rx_overrun from happening.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SPI_M_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_NOT_BUSY_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Status and unmasked interrupt flag for transfer not busy. The interrupt is cleared implicitly when writing new TX data. Active when no transfer ongoing and no data in TX buffer.</description>
            </field>
            <field>
              <name>UNMASKED_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a rx data buffer overrun event. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW.</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>KEYPAD</name>
      <baseAddress>0x400010E0</baseAddress>
      <registers>
        <register>
          <name>KEYPAD_KEYPAD_CONFIG</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEYPAD_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Keypad scan enabled</description>
            </field>
            <field>
              <name>SENSITIVE_DURING_ACTIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>When &amp;apos;1&amp;apos; the scan outputs are driven to 0 during active to allow new keypad press to be detected</description>
            </field>
            <field>
              <name>PROLONGED_ROW_DRIVE</name>
              <bitRange>[2:2]</bitRange>
              <description>When &amp;apos;1&amp;apos;, the scan outputs are driven to 0 after the real measurement (debug)</description>
            </field>
            <field>
              <name>SSO_SPREAD_ENABLE</name>
              <bitRange>[3:3]</bitRange>
              <description>Spreads output changes over time to reduce sso effects</description>
            </field>
            <field>
              <name>ENABLE_CLK_KEYPAD_BY_UC</name>
              <bitRange>[4:4]</bitRange>
              <description>Enables clock gating (to be enabled when changing sensitive_during_active setting)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_ACTIVE_COLUMNS_CHARGE_PERIOD</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x000000FF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ACTIVE_COLUMNS_CHARGE_PERIOD</name>
              <bitRange>[7:0]</bitRange>
              <description>Active columns charge period selection: 0=250ns 1=500ns, 2=750ns, ..., FF= disabled</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_PASSIVE_COLUMNS_CHARGE_PERIOD</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x000000FF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PASSIVE_COLUMNS_CHARGE_PERIOD</name>
              <bitRange>[7:0]</bitRange>
              <description>Passive columns charge period selection: 0=250ns 1=500ns, 2=750ns, ..., FF= disabled</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_ROW_DRIVE_PERIOD</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ROW_DRIVE_PERIOD</name>
              <bitRange>[7:0]</bitRange>
              <description>Time that scan outputs are driven to 0 before measurement is done:0=250ns 1=500ns, 2=750ns, ..., FF = 63750ns</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEYPAD_STATE</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>KEYPAD_SCAN_BUSY</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates if a keypad scan is busy</description>
            </field>
            <field>
              <name>KEYPAD_SCAN_STATE</name>
              <bitRange>[3:1]</bitRange>
              <description>Indicates the state of a ongoing keypad scan</description>
            </field>
            <field>
              <name>KEYPAD_SCAN_COUNTER</name>
              <bitRange>[6:4]</bitRange>
              <description>Indicates the row counter of a ongoing keypad scan</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEYPAD_STATUS</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>RESULTS_UPDATED</name>
              <bitRange>[0:0]</bitRange>
              <description>Results updated indication: this bit is set to 0x1 when one of the scan results is updated, cleared by writing 0x1 to clear_results_updated</description>
            </field>
            <field>
              <name>RESULTS_CHANGED</name>
              <bitRange>[1:1]</bitRange>
              <description>Results changed indication: this bit is set to 0x1 when one of the scan results is updated and was different from previous value, cleared by writing 0x1 to clear_results_changed</description>
            </field>
            <field>
              <name>RESULTS_VALID</name>
              <bitRange>[2:2]</bitRange>
              <description>Results valid indication: this bit is set to 0x1 when all of the keypad scan&amp;apos;s inputs are connected to the device&amp;apos;s input pads. Cleared by writing 0x1 to clear_results_valid</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEYPAD_SCANS</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>KEYPAD_SCANS</name>
              <bitRange>[7:0]</bitRange>
              <description>Read back of keypad scan output value</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEYPAD_SENSES_ACTIVE_CHARGE</name>
          <addressOffset>0x0007</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>KEYPAD_SENSES_ACTIVE_CHARGE</name>
              <bitRange>[7:0]</bitRange>
              <description>Read back of keypad senses active charge output value</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEYPAD_SENSES</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>KEYPAD_SENSES</name>
              <bitRange>[7:0]</bitRange>
              <description>Read back of keypad senses input value</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_RESULTS_STABLE_COUNTER</name>
          <addressOffset>0x000A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RESULTS_STABLE_COUNTER</name>
              <bitRange>[7:0]</bitRange>
              <description>Counts the number of consecutive times the same result was detected, cleared by writing 0x0</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEYPAD_RESULT_SUMMARY</name>
          <addressOffset>0x000B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>NUMBER_OF_KEYS</name>
              <bitRange>[1:0]</bitRange>
              <description>Number of keys detected, 0=no key, 1=single key, 2=two keys, 3= more than 2 keys.</description>
            </field>
            <field>
              <name>SINGLE_KEY_SCAN</name>
              <bitRange>[4:2]</bitRange>
              <description>Single key scan (row) number (0...7).</description>
            </field>
            <field>
              <name>SINGLE_KEY_SENSE</name>
              <bitRange>[7:5]</bitRange>
              <description>Single key sense (column) number (0...7).</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_0</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_0</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 0.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_1</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_1</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 1.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_2</name>
          <addressOffset>0x000E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_2</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 2.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_3</name>
          <addressOffset>0x000F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_3</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 3.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_4</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_4</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 4.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_5</name>
          <addressOffset>0x0011</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_5</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 5.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_6</name>
          <addressOffset>0x0012</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_6</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 6.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEY_VECTOR_7</name>
          <addressOffset>0x0013</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY_VECTOR_7</name>
              <bitRange>[7:0]</bitRange>
              <description>Key sense vector 7.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_0X00000014</name>
          <addressOffset>0x0014</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_SCAN_DONE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Masked interrupt event status,  Active when 0x1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>KEYPAD_KEYPAD_RETENTION</name>
          <addressOffset>0x0016</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RETENTION_UNMASKED_SCAN_DONE_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Retention unmasked keypad interrupt</description>
            </field>
            <field>
              <name>RETENTION_RESULTS_UPDATED</name>
              <bitRange>[1:1]</bitRange>
              <description>Retention results updated</description>
            </field>
            <field>
              <name>RETENTION_RESULTS_CHANGED</name>
              <bitRange>[2:2]</bitRange>
              <description>Retention results changed</description>
            </field>
            <field>
              <name>RETENTION_RESULTS_VALID</name>
              <bitRange>[3:3]</bitRange>
              <description>Retention results valid</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>IR</name>
      <baseAddress>0x40001100</baseAddress>
      <registers>
        <register>
          <name>IR_PRESCALE_DIV</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRESCALE_DIV</name>
              <bitRange>[2:0]</bitRange>
              <description>Sets the divide factor for the prescaler. The prescaled frequecy is 16MHz/(2**prescale_div).</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_THRESHOLD</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>THRESHOLD</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the &amp;apos;on&amp;apos; time of the pwm carrier expressed in prescale clock periods. On time is: Ton = Tprescale*(threshold+1). Setting used when use_alt_carrier_configuration equals &amp;apos;0&amp;apos;.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_WRAP</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000003</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WRAP</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the PWM carrier period as a function of the prescale period. Tcarrierper = Tprescale*(wrap+1). Setting used when use_alt_carrier_configuration equals &amp;apos;0&amp;apos;.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_ALT_THRESHOLD</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ALT_THRESHOLD</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the &amp;apos;on&amp;apos; time of the pwm carrier expressed in prescale clock periods. On time is: Ton = Tprescale*(threshold+1). Setting used when use_alt_carrier_configuration equals &amp;apos;1&amp;apos;.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_ALT_WRAP</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000003</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ALT_WRAP</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the PWM carrier period as a function of the prescale period. Tcarrierper = Tprescale*(wrap+1). Setting used when use_alt_carrier_configuration equals &amp;apos;1&amp;apos;.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_CARRIER_TU</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CARRIER_TU</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the carrier Tu in number of carrier rising edges. Is used when ir  driver is in pattern mode</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_TIMER_TU</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000001</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMER_TU</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the time unit for the time based ram sequence mode. The time unit can be 500ns, 1us(=default), 2us or 4 us</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_MODULATION_CONTROL_0</name>
          <addressOffset>0x0007</addressOffset>
          <size>8</size>
          <resetValue>0x00000018</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MODULATION_MODE</name>
              <bitRange>[2:0]</bitRange>
              <description>Selects what source will be used for envelope modulation. Can be from registermap, from external pin, from  event scheduler or from ram sequence</description>
            </field>
            <field>
              <name>ALIGN_ON_START</name>
              <bitRange>[3:3]</bitRange>
              <description>When set to &amp;apos;1&amp;apos;, the carrier only starts running when the modulation is on. So the carrier is always aligned with the modulation start</description>
            </field>
            <field>
              <name>MODULATION_LATCH_ON_START</name>
              <bitRange>[4:4]</bitRange>
              <description>When set to &amp;apos;1&amp;apos;, the value of the modulation (or envelope) is sampled when the carrier period starts. In this way it can be guaranteed that carrier period is not interrupted (so no glitches)</description>
            </field>
            <field>
              <name>MODULATION</name>
              <bitRange>[5:5]</bitRange>
              <description>direct control of the modulation in the case the register_based modulation mode is chosen</description>
            </field>
            <field>
              <name>REPEAT_SEQUENCE</name>
              <bitRange>[6:6]</bitRange>
              <description>When set to &amp;apos;1&amp;apos;, the ram sequence will be repeated when it is finished (only for time_based and pattern_based modes)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_MODULATION_CONTROL_1</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_START</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to &amp;apos;1&amp;apos;, the ram sequence start pointer and ram sequence length are latched when a ram sequence is fired (only for time_based and pattern_based modes)</description>
            </field>
            <field>
              <name>LATCH_RAM_SEQUENCE_START_PTR_AND_LEN_ON_REPEAT</name>
              <bitRange>[1:1]</bitRange>
              <description>When set to &amp;apos;1&amp;apos;, the ram sequence start pointer and ram sequence length are latched when a ram sequence is repeated, because the repeat seuance bit was set (only for time_based and pattern_based modes)</description>
            </field>
            <field>
              <name>TOGGLE_ALT_CARRIER_CONFIG_ON_INDEX_MATCH</name>
              <bitRange>[2:2]</bitRange>
              <description>When set to &amp;apos;1&amp;apos;, the use_alt_carrier_config will be toggle on an index match (only for time_based and pattern_based modes)</description>
            </field>
            <field>
              <name>SENSITIVE_FOR_ES_START</name>
              <bitRange>[3:3]</bitRange>
              <description>When set to &amp;apos;1&amp;apos;, the ram sequencer can be start by the ES (only for time_based and pattern_based modes)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_RAM_SEQUENCE_START_PTR</name>
          <addressOffset>0x000A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RAM_SEQUENCE_START_PTR</name>
              <bitRange>[15:0]</bitRange>
              <description>Sets the start pointer of the ram modulation sequence block (16 bit word address offset with respect to RAM start adddress)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_RAM_SEQUENCE_LEN</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RAM_SEQUENCE_LEN</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the length of the ram sequence - len is set to number of entries - 1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_RAM_SEQUENCE_MATCH_INDEX</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RAM_SEQUENCE_MATCH_INDEX</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the index value that is checked for matches</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_MODULATION_STATUS</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>BUSY</name>
              <bitRange>[0:0]</bitRange>
              <description>ram sequence is ongoing</description>
            </field>
            <field>
              <name>MEM_ERR</name>
              <bitRange>[1:1]</bitRange>
              <description>indicates that the ram sequence was aborted because of a memory access err-or</description>
            </field>
            <field>
              <name>ENVELOPE</name>
              <bitRange>[2:2]</bitRange>
              <description>Shows the status of the envelope - just for observability</description>
            </field>
            <field>
              <name>CARRIER</name>
              <bitRange>[3:3]</bitRange>
              <description>Shows the status of the carrier - just for observability</description>
            </field>
            <field>
              <name>USE_ALT_CARRIER_CONFIG</name>
              <bitRange>[4:4]</bitRange>
              <description>when &amp;apos;0&amp;apos;, threshold and wrap are used for carrier generation. when &amp;apos;1&amp;apos;, alt_threshold and alt_wrap are used for carrier generation.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_INTERRUPT_STATUS</name>
          <addressOffset>0x0011</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_SEQUENCE_START_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>unmasked interrupt status of the interrupt triggered by starting a ram sequence</description>
            </field>
            <field>
              <name>UNMASKED_SEQUENCE_REPEAT_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>unmasked interrupt status of the interrupt triggered by repeating a ram sequence</description>
            </field>
            <field>
              <name>UNMASKED_SEQUENCE_DONE_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>unmasked interrupt status of the interrupt triggered by finishing a ram sequence</description>
            </field>
            <field>
              <name>UNMASKED_INDEX_MATCH_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>unmasked interrupt status of the interrupt triggered by the ram sequence hitting a certain index</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_SEQUENCE_IDX</name>
          <addressOffset>0x0012</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>SEQUENCE_IDX</name>
              <bitRange>[7:0]</bitRange>
              <description>shows the what index in the ram sequence is currently being executed</description>
            </field>
          </fields>
        </register>

        <register>
          <name>IR_IO_CONTROL</name>
          <addressOffset>0x0013</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>OUTPUT_DRIVE</name>
              <bitRange>[0:0]</bitRange>
              <description>Sets the drive type for the output</description>
            </field>
            <field>
              <name>OUTPUT_INVERT</name>
              <bitRange>[1:1]</bitRange>
              <description>Inverts the output</description>
            </field>
            <field>
              <name>INPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>inverts the input</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>WATCHDOG</name>
      <baseAddress>0x40001120</baseAddress>
      <registers>
        <register>
          <name>WATCHDOG_CONTROL</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Watchdog enabled when 0x1 - Writing this register only has effect when in the control settings change sequence</description>
            </field>
            <field>
              <name>WATCHDOG_FUNCTION</name>
              <bitRange>[3:1]</bitRange>
              <description>Function of watchdog, triggered when timer reaches zero - Writing this register only has effect when in the control settings change sequence</description>
            </field>
            <field>
              <name>ENABLE_KEEP_ALIVE</name>
              <bitRange>[4:4]</bitRange>
              <description>When set to 1 a keep alive mechanism is enabled, where the standby RC clock is used to check if the main clock is still runninig. A POR will be triggered if the main clock is not running</description>
            </field>
          </fields>
        </register>

        <register>
          <name>WATCHDOG_TIMEOUT</name>
          <addressOffset>0x0002</addressOffset>
          <size>16</size>
          <resetValue>0x0000FFFF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMEOUT</name>
              <bitRange>[15:0]</bitRange>
              <description>Watchdog timeout value in 16 us -  Writing this register only has effect when in the control settings change sequence</description>
            </field>
          </fields>
        </register>

        <register>
          <name>WATCHDOG_CONFIG</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>FREEZE_WHEN_UC_ASLEEP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, the watchdog timer will be frozen whan the internal uc goes to sleep</description>
            </field>
            <field>
              <name>FREEZE_WHEN_UC_BREAK_POINT</name>
              <bitRange>[1:1]</bitRange>
              <description>When set to 1, the watchdog timer will be frozen whan the internal uc hits a break point in debug mode</description>
            </field>
          </fields>
        </register>

        <register>
          <name>WATCHDOG_STATUS</name>
          <addressOffset>0x0007</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>CONTROL_CHANGE_WINDOW_ONGOING</name>
              <bitRange>[0:0]</bitRange>
              <description>This status bit indicates that the window for changing watchdog control settings is open. Control settings can only be changed when this status bit is 1</description>
            </field>
            <field>
              <name>UNMASKED_TIMER_EXPIRED_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Unmasked status of the timer expired interrupt</description>
            </field>
            <field>
              <name>TIMER_EXPIRED</name>
              <bitRange>[2:2]</bitRange>
              <description>Indicates that the timer has reached 0. This status is reset by a watchdog reset, or by a control settings change</description>
            </field>
          </fields>
        </register>

        <register>
          <name>WATCHDOG_CURRENT_TIME</name>
          <addressOffset>0x0008</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>CURRENT_TIME</name>
              <bitRange>[15:0]</bitRange>
              <description>Watchdog current time (16 us multiples)</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>LEDS</name>
      <baseAddress>0x40001140</baseAddress>
      <registers>
        <register>
          <name>LEDS_CONTROL_0</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED0_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Set to 1 to enable the led</description>
            </field>
            <field>
              <name>LED0_FADE</name>
              <bitRange>[1:1]</bitRange>
              <description>When set to 1, fading will be used when enabling or disabling the led</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_0X00000001</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x000000FF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED0_THRESHOLD</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the target PWM threshold (255 =  max duty cycle)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_LED0_IO_CONTROL</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED0_OUTPUT_DRIVE</name>
              <bitRange>[0:0]</bitRange>
              <description>Sets the drive type for the output</description>
            </field>
            <field>
              <name>LED0_OUTPUT_INVERT</name>
              <bitRange>[1:1]</bitRange>
              <description>Inverts the output</description>
            </field>
            <field>
              <name>LED0_ALLOW_GOTOSLEEP_WHEN_ON</name>
              <bitRange>[2:2]</bitRange>
              <description>When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_CONTROL_1</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED1_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Set to 1 to enable the led</description>
            </field>
            <field>
              <name>LED1_FADE</name>
              <bitRange>[1:1]</bitRange>
              <description>When set to 1, fading will be used when enabling or disabling the led</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_0X00000005</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x000000FF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED1_THRESHOLD</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the target PWM threshold (255 =  max duty cycle)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_LED1_IO_CONTROL</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED1_OUTPUT_DRIVE</name>
              <bitRange>[0:0]</bitRange>
              <description>Sets the drive type for the output</description>
            </field>
            <field>
              <name>LED1_OUTPUT_INVERT</name>
              <bitRange>[1:1]</bitRange>
              <description>Inverts the output</description>
            </field>
            <field>
              <name>LED1_ALLOW_GOTOSLEEP_WHEN_ON</name>
              <bitRange>[2:2]</bitRange>
              <description>When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_CONTROL_2</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED2_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Set to 1 to enable the led</description>
            </field>
            <field>
              <name>LED2_FADE</name>
              <bitRange>[1:1]</bitRange>
              <description>When set to 1, fading will be used when enabling or disabling the led</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_0X00000009</name>
          <addressOffset>0x0009</addressOffset>
          <size>8</size>
          <resetValue>0x000000FF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED2_THRESHOLD</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the target PWM threshold (255 =  max duty cycle)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_LED2_IO_CONTROL</name>
          <addressOffset>0x000A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED2_OUTPUT_DRIVE</name>
              <bitRange>[0:0]</bitRange>
              <description>Sets the drive type for the output</description>
            </field>
            <field>
              <name>LED2_OUTPUT_INVERT</name>
              <bitRange>[1:1]</bitRange>
              <description>Inverts the output</description>
            </field>
            <field>
              <name>LED2_ALLOW_GOTOSLEEP_WHEN_ON</name>
              <bitRange>[2:2]</bitRange>
              <description>When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_CONTROL_3</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED3_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Set to 1 to enable the led</description>
            </field>
            <field>
              <name>LED3_FADE</name>
              <bitRange>[1:1]</bitRange>
              <description>When set to 1, fading will be used when enabling or disabling the led</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_0X0000000D</name>
          <addressOffset>0x000D</addressOffset>
          <size>8</size>
          <resetValue>0x000000FF</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED3_THRESHOLD</name>
              <bitRange>[7:0]</bitRange>
              <description>Sets the target PWM threshold (255 =  max duty cycle)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_LED3_IO_CONTROL</name>
          <addressOffset>0x000E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>LED3_OUTPUT_DRIVE</name>
              <bitRange>[0:0]</bitRange>
              <description>Sets the drive type for the output</description>
            </field>
            <field>
              <name>LED3_OUTPUT_INVERT</name>
              <bitRange>[1:1]</bitRange>
              <description>Inverts the output</description>
            </field>
            <field>
              <name>LED3_ALLOW_GOTOSLEEP_WHEN_ON</name>
              <bitRange>[2:2]</bitRange>
              <description>When set, the chip may go to sleep, even if the led is driven continuously (dutycycling prevents chip from going to sleep)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_TIMER_CONFIG</name>
          <addressOffset>0x000F</addressOffset>
          <size>8</size>
          <resetValue>0x00000033</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MAIN_TMR</name>
              <bitRange>[2:0]</bitRange>
              <description>Sets the timer to use for the main counter, which gets compared to the thresholds</description>
            </field>
            <field>
              <name>SLOPE_TMR</name>
              <bitRange>[6:4]</bitRange>
              <description>Sets the timer to use for updating the threshold, each slope timer wrap shall increment/decrement the threshold (if fading is enabled)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>LEDS_0X00000010</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>DUMMY_STATUS</name>
              <bitRange>[0:0]</bitRange>
              <description>dummy - regmap generation thing ...</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>SPI_SL</name>
      <baseAddress>0x400011C0</baseAddress>
      <registers>
        <register>
          <name>SPI_SL_CONFIG</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000006</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable core when &amp;apos;1&amp;apos;</description>
            </field>
            <field>
              <name>CLR_RX_FIFO_ON_DESELECT</name>
              <bitRange>[1:1]</bitRange>
              <description>When set, the rx data byte buffer will be cleared whn the ssn pin is inactive</description>
            </field>
            <field>
              <name>CLR_TX_FIFO_ON_DESELECT</name>
              <bitRange>[2:2]</bitRange>
              <description>When set, the tx data byte buffer will be cleared whn the ssn pin is inactive</description>
            </field>
            <field>
              <name>TX_LATENCY</name>
              <bitRange>[6:3]</bitRange>
              <description>Amount of dummy of bytes that shift out of the MISO after the slave is selected and before real data is transmitted. Number of dummy bytes = tx_latency + 1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>SPI_SL_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_TX_EMPTY_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Status and unmasked interrupt flag for TX bufferbeing empty. The interrupt is cleared implicitly when writing new TX data fills the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_TX_UNDERRUN_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Status and unmasked interrupt flag for the occurrence of a tx data buffer underrun. Set when the tx data buffer is empty when master pulls data from slave. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>UNMASKED_RX_OVERRUN_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Status and unmasked interrupt flag for the occurrence of a rx data buffer overrun. Set when the rx data buffer is full and new rx data is available. Cleared explicitly by the SW.</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>I2C_SL</name>
      <baseAddress>0x400011E0</baseAddress>
      <registers>
        <register>
          <name>I2C_SL_SLAVE_ADDRESS</name>
          <addressOffset>0x0002</addressOffset>
          <size>16</size>
          <resetValue>0x0000004E</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SLAVE_ADDRESS</name>
              <bitRange>[9:0]</bitRange>
              <description>I2C slave address</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2C_SL_CONFIG</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000004</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable core when &amp;apos;1&amp;apos;</description>
            </field>
            <field>
              <name>SCL_STRETCH_EN</name>
              <bitRange>[1:1]</bitRange>
              <description>Enable clock stretching by the slave.</description>
            </field>
            <field>
              <name>ACCEPT_GENERAL_CALL</name>
              <bitRange>[2:2]</bitRange>
              <description>Enable slave selection via the general call address.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2C_SL_STATUS</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>READ_FLAG</name>
              <bitRange>[0:0]</bitRange>
              <description>Status of the RnW bit of the last successful slave addressing. When 0, this indicated master-to-slave direction. When 0, this indicated slave-to-master direction. The flag is updated on each slad event.</description>
            </field>
            <field>
              <name>GENERAL_CALL_FLAG</name>
              <bitRange>[1:1]</bitRange>
              <description>Status of the address match of the last successful slave addressing . When 0, the slave was selected by its own address. When 1, the slave was selected by the general call address (= all 0).  The flag is updated on each slad event.</description>
            </field>
            <field>
              <name>BUSY</name>
              <bitRange>[2:2]</bitRange>
              <description>When 1, an I2C transfer is busy  Set upon a START event, cleared upon a STOP event.</description>
            </field>
            <field>
              <name>BUSY_SLAD</name>
              <bitRange>[3:3]</bitRange>
              <description>When 1, the slave is currently selected, an I2C transfer is busy.  Set upon a SLAD event, cleared upon a STOP event.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2C_SL_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Status and unmasked interrupt flag for TX buffer not full. The interrupt is set when TX data is ready to accept new bytes.</description>
            </field>
            <field>
              <name>UNMASKED_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_TX_STRETCH_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>Status and unmasked interrupt flag for SCL stretching ongoing. The interrupt is active when SCL is being stretched by the slave. SCL stretching occurs when scl_stretch_en = &amp;apos;1&amp;apos;, the slave has been successfully addressed in read direction, and the tx_data FIFO is empty. This interrupt can be used to trigger writes to tx_data.</description>
            </field>
            <field>
              <name>UNMASKED_START_INTERRUPT</name>
              <bitRange>[3:3]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a START condition on the I2C bus. Set when a START or a repeated START condition is detected. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>UNMASKED_STOP_INTERRUPT</name>
              <bitRange>[4:4]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a STOP condition on the I2C bus. Set when the STOP condition is detected. Cleared explicitly by the SW.</description>
            </field>
            <field>
              <name>UNMASKED_SLAD_INTERRUPT</name>
              <bitRange>[5:5]</bitRange>
              <description>Event and unmasked interrupt flag for the occurrence of a SLAD event (slave addressed). Set when this slave has been (re-)selected or upon a general call. Cleared explicitly by the SW.</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>DMAS</name>
      <baseAddress>0x40001200</baseAddress>
      <registers>
        <register>
          <name>DMAS_0X00000000[0]</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_0[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000000[1]</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_0[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000000[2]</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_0[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000004[0]</name>
          <addressOffset>0x0004</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_0[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000004[1]</name>
          <addressOffset>0x0005</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_0[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000004[2]</name>
          <addressOffset>0x0006</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_0[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000008</name>
          <addressOffset>0x0008</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_0</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_0, depending on circular_buffer_select_0. Expressed as a multiple of the DMA memory access unit. buffer_size_0=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000000A</name>
          <addressOffset>0x000A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_0</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_0. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_0. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_0.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000000C</name>
          <addressOffset>0x000C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_0</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000000E</name>
          <addressOffset>0x000E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_0</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_0</name>
          <addressOffset>0x0010</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_0</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_0</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_0</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_0 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_0</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_0</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000012</name>
          <addressOffset>0x0012</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_0</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_0&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000013</name>
          <addressOffset>0x0013</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_0</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_0</name>
          <addressOffset>0x0018</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_0_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_0 = error_mode overflow (for circular_buffer_select_0 = dest_buffer) or underrun (for circular_buffer_select_0 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_0 = status_mode it indicates full (for circular_buffer_select_0 = dest_buffer) or empty (for circular_buffer_select_0 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_0_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_0. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000001C[0]</name>
          <addressOffset>0x001C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_1[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000001C[1]</name>
          <addressOffset>0x001D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_1[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000001C[2]</name>
          <addressOffset>0x001E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_1[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000020[0]</name>
          <addressOffset>0x0020</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_1[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000020[1]</name>
          <addressOffset>0x0021</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_1[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000020[2]</name>
          <addressOffset>0x0022</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_1[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000024</name>
          <addressOffset>0x0024</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_1</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_1, depending on circular_buffer_select_1. Expressed as a multiple of the DMA memory access unit. buffer_size_1=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000026</name>
          <addressOffset>0x0026</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_1</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_1. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_1. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_1.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000028</name>
          <addressOffset>0x0028</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_1</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000002A</name>
          <addressOffset>0x002A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_1</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_1</name>
          <addressOffset>0x002C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_1</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_1</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_1</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_1 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_1</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_1</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000002E</name>
          <addressOffset>0x002E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_1</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_1&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000002F</name>
          <addressOffset>0x002F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_1</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_1</name>
          <addressOffset>0x0034</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_1_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_1 = error_mode overflow (for circular_buffer_select_1 = dest_buffer) or underrun (for circular_buffer_select_1 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_1 = status_mode it indicates full (for circular_buffer_select_1 = dest_buffer) or empty (for circular_buffer_select_1 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_1_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_1. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000038[0]</name>
          <addressOffset>0x0038</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_2[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000038[1]</name>
          <addressOffset>0x0039</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_2[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000038[2]</name>
          <addressOffset>0x003A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_2[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000003C[0]</name>
          <addressOffset>0x003C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_2[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000003C[1]</name>
          <addressOffset>0x003D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_2[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000003C[2]</name>
          <addressOffset>0x003E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_2[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000040</name>
          <addressOffset>0x0040</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_2</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_2, depending on circular_buffer_select_2. Expressed as a multiple of the DMA memory access unit. buffer_size_2=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000042</name>
          <addressOffset>0x0042</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_2</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_2. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_2. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_2.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000044</name>
          <addressOffset>0x0044</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_2</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000046</name>
          <addressOffset>0x0046</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_2</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_2</name>
          <addressOffset>0x0048</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_2</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_2</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_2</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_2 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_2</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_2</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000004A</name>
          <addressOffset>0x004A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_2</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_2&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000004B</name>
          <addressOffset>0x004B</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_2</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_2</name>
          <addressOffset>0x0050</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_2_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_2 = error_mode overflow (for circular_buffer_select_2 = dest_buffer) or underrun (for circular_buffer_select_2 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_2 = status_mode it indicates full (for circular_buffer_select_2 = dest_buffer) or empty (for circular_buffer_select_2 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_2_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_2. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000054[0]</name>
          <addressOffset>0x0054</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_3[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000054[1]</name>
          <addressOffset>0x0055</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_3[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000054[2]</name>
          <addressOffset>0x0056</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_3[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000058[0]</name>
          <addressOffset>0x0058</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_3[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000058[1]</name>
          <addressOffset>0x0059</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_3[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000058[2]</name>
          <addressOffset>0x005A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_3[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000005C</name>
          <addressOffset>0x005C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_3</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_3, depending on circular_buffer_select_3. Expressed as a multiple of the DMA memory access unit. buffer_size_3=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000005E</name>
          <addressOffset>0x005E</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_3</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_3. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_3. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_3.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000060</name>
          <addressOffset>0x0060</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_3</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000062</name>
          <addressOffset>0x0062</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_3</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_3</name>
          <addressOffset>0x0064</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_3</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_3</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_3</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_3 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_3</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_3</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000066</name>
          <addressOffset>0x0066</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_3</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_3&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000067</name>
          <addressOffset>0x0067</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_3</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_3</name>
          <addressOffset>0x006C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_3_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_3 = error_mode overflow (for circular_buffer_select_3 = dest_buffer) or underrun (for circular_buffer_select_3 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_3 = status_mode it indicates full (for circular_buffer_select_3 = dest_buffer) or empty (for circular_buffer_select_3 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_3_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_3. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000070[0]</name>
          <addressOffset>0x0070</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_4[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000070[1]</name>
          <addressOffset>0x0071</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_4[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000070[2]</name>
          <addressOffset>0x0072</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_4[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000074[0]</name>
          <addressOffset>0x0074</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_4[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000074[1]</name>
          <addressOffset>0x0075</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_4[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000074[2]</name>
          <addressOffset>0x0076</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_4[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000078</name>
          <addressOffset>0x0078</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_4</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_4, depending on circular_buffer_select_4. Expressed as a multiple of the DMA memory access unit. buffer_size_4=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000007A</name>
          <addressOffset>0x007A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_4</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_4. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_4. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_4.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000007C</name>
          <addressOffset>0x007C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_4</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000007E</name>
          <addressOffset>0x007E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_4</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_4</name>
          <addressOffset>0x0080</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_4</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_4</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_4</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_4 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_4</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_4</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000082</name>
          <addressOffset>0x0082</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_4</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_4&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000083</name>
          <addressOffset>0x0083</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_4</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_4</name>
          <addressOffset>0x0088</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_4_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_4 = error_mode overflow (for circular_buffer_select_4 = dest_buffer) or underrun (for circular_buffer_select_4 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_4 = status_mode it indicates full (for circular_buffer_select_4 = dest_buffer) or empty (for circular_buffer_select_4 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_4_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_4. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000008C[0]</name>
          <addressOffset>0x008C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_5[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000008C[1]</name>
          <addressOffset>0x008D</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_5[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000008C[2]</name>
          <addressOffset>0x008E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_5[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000090[0]</name>
          <addressOffset>0x0090</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_5[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000090[1]</name>
          <addressOffset>0x0091</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_5[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000090[2]</name>
          <addressOffset>0x0092</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_5[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000094</name>
          <addressOffset>0x0094</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_5</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_5, depending on circular_buffer_select_5. Expressed as a multiple of the DMA memory access unit. buffer_size_5=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000096</name>
          <addressOffset>0x0096</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_5</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_5. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_5. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_5.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X00000098</name>
          <addressOffset>0x0098</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_5</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000009A</name>
          <addressOffset>0x009A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_5</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_5</name>
          <addressOffset>0x009C</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_5</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_5</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_5</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_5 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_5</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_5</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000009E</name>
          <addressOffset>0x009E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_5</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_5&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X0000009F</name>
          <addressOffset>0x009F</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_5</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_5</name>
          <addressOffset>0x00A4</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_5_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_5 = error_mode overflow (for circular_buffer_select_5 = dest_buffer) or underrun (for circular_buffer_select_5 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_5 = status_mode it indicates full (for circular_buffer_select_5 = dest_buffer) or empty (for circular_buffer_select_5 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_5_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_5. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000A8[0]</name>
          <addressOffset>0x00A8</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_6[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000A8[1]</name>
          <addressOffset>0x00A9</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_6[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000A8[2]</name>
          <addressOffset>0x00AA</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_6[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000AC[0]</name>
          <addressOffset>0x00AC</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_6[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000AC[1]</name>
          <addressOffset>0x00AD</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_6[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000AC[2]</name>
          <addressOffset>0x00AE</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_6[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000B0</name>
          <addressOffset>0x00B0</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_6</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_6, depending on circular_buffer_select_6. Expressed as a multiple of the DMA memory access unit. buffer_size_6=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000B2</name>
          <addressOffset>0x00B2</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_6</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_6. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_6. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_6.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000B4</name>
          <addressOffset>0x00B4</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_6</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000B6</name>
          <addressOffset>0x00B6</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_6</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_6</name>
          <addressOffset>0x00B8</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_6</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_6</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_6</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_6 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_6</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_6</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000BA</name>
          <addressOffset>0x00BA</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_6</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_6&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000BB</name>
          <addressOffset>0x00BB</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_6</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_6</name>
          <addressOffset>0x00C0</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_6_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_6 = error_mode overflow (for circular_buffer_select_6 = dest_buffer) or underrun (for circular_buffer_select_6 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_6 = status_mode it indicates full (for circular_buffer_select_6 = dest_buffer) or empty (for circular_buffer_select_6 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_6_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_6. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000C4[0]</name>
          <addressOffset>0x00C4</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_7[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000C4[1]</name>
          <addressOffset>0x00C5</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_7[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000C4[2]</name>
          <addressOffset>0x00C6</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>SRC_ADDR_7[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the source to be copied from. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000C8[0]</name>
          <addressOffset>0x00C8</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_7[0]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000C8[1]</name>
          <addressOffset>0x00C9</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_7[1]</name>
              <bitRange>[7:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000C8[2]</name>
          <addressOffset>0x00CA</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEST_ADDR_7[2]</name>
              <bitRange>[4:0]</bitRange>
              <description>Start address of the destination to be copied to. The address needs to match an address boundary conforming to the DMA memory access unit size (i.e. the word mode)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000CC</name>
          <addressOffset>0x00CC</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_SIZE_7</name>
              <bitRange>[11:0]</bitRange>
              <description>Size of either the source or destination buffer_7, depending on circular_buffer_select_7. Expressed as a multiple of the DMA memory access unit. buffer_size_7=n_units-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000CE</name>
          <addressOffset>0x00CE</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_ALMOST_COMPLETE_THRESHOLD_7</name>
              <bitRange>[11:0]</bitRange>
              <description>Threshold to be used for generating either an almost empty or almost full interrupt, depending on circular_buffer_select_7. If SRC_BUFFER, interrupt is triggered when there are only (threshold-1) units left in the src buffer_7. If DEST_BUFFER, interrupt is triggered when there are (threshold+1) units written in the dest buffer_7.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000D0</name>
          <addressOffset>0x00D0</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_VALUE_7</name>
              <bitRange>[11:0]</bitRange>
              <description>Pointer value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000D2</name>
          <addressOffset>0x00D2</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>BUFFER_PTR_WRAP_VALUE_7</name>
              <bitRange>[0:0]</bitRange>
              <description>Pointer wrap value to be used when triggering the different pointer sets (allows for atomic pointer set)</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_CONFIG_7</name>
          <addressOffset>0x00D4</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>WORD_MODE_7</name>
              <bitRange>[1:0]</bitRange>
              <description>Sets the size of the memory access unit. DMA supports 8/16/32-bit memory access. byte = 8 bits, half_word = 16 bits, word = 32 bits</description>
            </field>
            <field>
              <name>CPY_TRIGGER_SRC_SELECT_7</name>
              <bitRange>[6:2]</bitRange>
              <description>Selects the slave interface that will be the source for triggering the dma copy action</description>
            </field>
            <field>
              <name>CPY_TRIGGER_BY_REGMAP_7</name>
              <bitRange>[7:7]</bitRange>
              <description>regmap cpy trigger_7 overrule. The dma copy will be triggered as long as this bit is set to 1</description>
            </field>
            <field>
              <name>BUFFER_COMPLETE_INTERRUPT_MODE_7</name>
              <bitRange>[8:8]</bitRange>
              <description>If set to error_mode then the buffer_complete interrupt indicates overflow/underrun conditions. Otherwise (status_mode) full/empty conditions are reported.</description>
            </field>
            <field>
              <name>ACCESS_LATENCY_7</name>
              <bitRange>[12:9]</bitRange>
              <description>Minimum number of idle cycles between accesses to the same dma channel. Should be increased for slowly responding cpy_triggers.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000D6</name>
          <addressOffset>0x00D6</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CPY_TRIGGER_IGNORE_BUFFER_COMPLETE_7</name>
              <bitRange>[0:0]</bitRange>
              <description>When enabled, the buffer_7&amp;apos;s completeness is ignored when triggering a dma copy action</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000D7</name>
          <addressOffset>0x00D7</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CIRCULAR_BUFFER_SELECT_7</name>
              <bitRange>[0:0]</bitRange>
              <description>Selects between source and destination as circular buffer locatio.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_STATUS_7</name>
          <addressOffset>0x00DC</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_BUFFER_COMPLETE_7_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Refers to the selected circular buffer. In buffer_complete_interrupt_mode_7 = error_mode overflow (for circular_buffer_select_7 = dest_buffer) or underrun (for circular_buffer_select_7 = src_buffer) errors are indicated. In buffer_complete_interrupt_mode_7 = status_mode it indicates full (for circular_buffer_select_7 = dest_buffer) or empty (for circular_buffer_select_7 = src_buffer) status.</description>
            </field>
            <field>
              <name>UNMASKED_BUFFER_ALMOST_COMPLETE_7_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Indicates that the almost complete threshold has been reached, actual level depends on the circular_buffer_select_7. See threshold setting for more info</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000DD</name>
          <addressOffset>0x00DD</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CLK_ENA</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the clock to the dma block when &amp;apos;1&amp;apos;</description>
            </field>
            <field>
              <name>CHANNEL_SWITCH_LATENCY</name>
              <bitRange>[4:1]</bitRange>
              <description>Minimum number of idle cycles between accesses to different dma channels. Should be used to reduce the dma memory bandwidth quota.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>DMAS_0X000000DF</name>
          <addressOffset>0x00DF</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_CPY_ERR_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Indicates that a memory acces failed during dma operation. This STOPS the dma operation. Dma can only be unlocked by clearing this interrupt</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>I2S_M</name>
      <baseAddress>0x40001300</baseAddress>
      <registers>
        <register>
          <name>I2S_M_CONFIG_0</name>
          <addressOffset>0x0004</addressOffset>
          <size>32</size>
          <resetValue>0x00100F10</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Starts the interface. Make sure the first databyte is already available in tx_data before enabling the interface.</description>
            </field>
            <field>
              <name>SELECT_CLK</name>
              <bitRange>[2:1]</bitRange>
              <description>Selects the processing clock of the interface.</description>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <bitRange>[3:3]</bitRange>
              <description>Enables the slave mode. When false, the interface is in master mode.</description>
            </field>
            <field>
              <name>WS_OFFSET</name>
              <bitRange>[6:4]</bitRange>
              <description>Offset in SCK cycles between the WS toggle and the first data bit. For real I2S mode, this should be 1.</description>
            </field>
            <field>
              <name>SCK_FREQ</name>
              <bitRange>[15:8]</bitRange>
              <description>SCK bit clock frequency prescaler: processing_clk_freq / 2*(sck_freq + 1)</description>
            </field>
            <field>
              <name>WORD_LEN</name>
              <bitRange>[23:16]</bitRange>
              <description>Length in SCK cycles between two consecutive WS toggles.</description>
            </field>
            <field>
              <name>TX_BYTES_LEFT</name>
              <bitRange>[26:24]</bitRange>
              <description>Number of data bytes (8-bit) to be transmitted on SDO for the left channel (WS=0). When word_len &amp;gt; 8*tx_bytes_left, SDO will be padded with 0. When word_len &amp;lt; 8*tx_bytes_left, the remaining bits (lsbs) will be ignored. If tx_bytes_left = 0, SDO will be 0 for this channel.</description>
            </field>
            <field>
              <name>TX_BYTES_RIGHT</name>
              <bitRange>[29:27]</bitRange>
              <description>Number of data bytes to be transmitted on SDO for the right channel (WS=1). Same remarks as for tx_bytes_left.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2S_M_CONFIG_1</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000040</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>RX_BYTES_LEFT</name>
              <bitRange>[2:0]</bitRange>
              <description>Number of data bytes (8-bit) to be received on SDI for the left channel (WS=0). When word_len &amp;gt; 8*tx_bytes_left, the remaining bits on SDI will be ignored. When word_len &amp;lt; 8*tx_bytes_left, the remaining bits (lsbs) will be zero. If tx_bytes_left = 0, no data will be received for this channel.</description>
            </field>
            <field>
              <name>RX_BYTES_RIGHT</name>
              <bitRange>[5:3]</bitRange>
              <description>Number of data bytes (8-bit) to be received on SDI for the right channel (WS=1). Same remarks as for rx_bytes_left.</description>
            </field>
            <field>
              <name>ENABLE_PRESCALER</name>
              <bitRange>[6:6]</bitRange>
              <description>Enables the SCK clock prescaler. Only applicable when select_clk /= MAIN_CLK. The prescaler is always enabled when select_clk = MAIN_CLK.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>I2S_M_UNMASKED_INTERRUPTS</name>
          <addressOffset>0x0009</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_TX_NOT_FULL_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Status and unmasked interrupt flag for TX buffer not full. The interrupt is cleared implicitly when writing new TX data fills the buffer.</description>
            </field>
            <field>
              <name>UNMASKED_RX_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Status and unmasked interrupt flag for RX buffer not empty. The interrupt is cleared implicitly when reading the last RX data from the buffer.</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>ASP</name>
      <baseAddress>0x40001320</baseAddress>
      <registers>
        <register>
          <name>ASP_CONFIG</name>
          <addressOffset>0x0000</addressOffset>
          <size>16</size>
          <resetValue>0x00000020</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>DECIMATION_FACTOR</name>
              <bitRange>[6:0]</bitRange>
              <description>Factor-1 with which the incoming pdm signal should be downsampled (actual decimation factor = value+1)</description>
            </field>
            <field>
              <name>BYPASS_CIC</name>
              <bitRange>[7:7]</bitRange>
              <description>Don&amp;apos;t filter the streams but convert them into a 16-bit word stream that can be read from the data register (lsb is the bit first received)</description>
            </field>
            <field>
              <name>DATA_SETUP_TIME</name>
              <bitRange>[9:8]</bitRange>
              <description>Number of 16 MHz periods after a rising/falling edge before the data is stable (nr_periods = value + 1)</description>
            </field>
            <field>
              <name>SAMPLE_DATASTREAM_0_SETTING</name>
              <bitRange>[11:10]</bitRange>
              <description>Enable capturing data on specified mode on the dut</description>
            </field>
            <field>
              <name>SAMPLE_DATASTREAM_1_SETTING</name>
              <bitRange>[13:12]</bitRange>
              <description>Enable capturing data on specified mode on the dut</description>
            </field>
            <field>
              <name>USE_FRACT_CLOCK</name>
              <bitRange>[14:14]</bitRange>
              <description>If set: use the fractional clock (see bbpll regmap). If not set: a 2MHz clk will be generated</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ASP_0X00000002</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PCM_LSB_OVERRULE</name>
              <bitRange>[3:0]</bitRange>
              <description>Sets the 16 bits to shift out of the (24 bit) pcm stream coming from the cic filter and into the data_out registers, when not overruled this is the value determined of theoretical max value</description>
            </field>
            <field>
              <name>PCM_LSB_OVERRULE_EN</name>
              <bitRange>[4:4]</bitRange>
              <description>Use pcm_lsb_overrule value</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ASP_0X00000003</name>
          <addressOffset>0x0003</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_DATASTREAM_0_VALID_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>Data is available from the data_0 register, is indirectly cleared by reading out the data</description>
            </field>
            <field>
              <name>UNMASKED_DATASTREAM_1_VALID_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>Data is available from the data_1 register, is indirectly cleared by reading out the data</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ASP_0X0000000C</name>
          <addressOffset>0x000C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>CLK_2M_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enable the 2MHz clock.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>ASP_0X0000000E</name>
          <addressOffset>0x000E</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>CIC_DIAGNOSTICS_OUT_OF_RANGE</name>
              <bitRange>[0:0]</bitRange>
              <description>Flag indicating that the CIC filter went out of range at least once since the last time the flags were cleared</description>
            </field>
            <field>
              <name>CIC_DIAGNOSTICS_FULL_RANGE_USED</name>
              <bitRange>[1:1]</bitRange>
              <description>Flag indicating that the CIC filter was using its full range at least once since the last time the flags were cleared</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

    <peripheral>
      <name>PWMS</name>
      <baseAddress>0x40001400</baseAddress>
      <registers>
        <register>
          <name>PWMS_0X00000000</name>
          <addressOffset>0x0000</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP0_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the timestamp0 functinality.</description>
            </field>
            <field>
              <name>TIMESTAMP0_FIFO_SIZE</name>
              <bitRange>[2:1]</bitRange>
              <description>When set to 1, the timestamp0 fifos works in 16-bit word mode. In this mode, reading the timestamp0_main property, pops an entry from the FIFO. When set to 0, the timestamp0 fifo works in byte mode. In this mode, writing the timestamp0 property pops an entry from the fifo.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_TIMESTAMP0_STABLE_POWERS</name>
          <addressOffset>0x0001</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP0_STABLE_LOW_POWER</name>
              <bitRange>[2:0]</bitRange>
              <description>The amount of timestamp0 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp0_stable_low_power)-1</description>
            </field>
            <field>
              <name>TIMESTAMP0_STABLE_HIGH_POWER</name>
              <bitRange>[6:4]</bitRange>
              <description>The amount of timestamp0 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp0_stable_high_power)-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_STATUS_0</name>
          <addressOffset>0x0002</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>TIMESTAMP0_INPUT</name>
              <bitRange>[0:0]</bitRange>
              <description>The current value of the timestamp0 input</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP0_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>The unmasked interrupt status of the timestamp0 not empty interrupt</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP0_OVERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>The unmasked interrupt status of the timestamp0 overrun interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000008</name>
          <addressOffset>0x0008</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP1_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the timestamp1 functinality.</description>
            </field>
            <field>
              <name>TIMESTAMP1_FIFO_SIZE</name>
              <bitRange>[2:1]</bitRange>
              <description>When set to 1, the timestamp1 fifos works in 16-bit word mode. In this mode, reading the timestamp1_main property, pops an entry from the FIFO. When set to 0, the timestamp1 fifo works in byte mode. In this mode, writing the timestamp1 property pops an entry from the fifo.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_TIMESTAMP1_STABLE_POWERS</name>
          <addressOffset>0x0009</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP1_STABLE_LOW_POWER</name>
              <bitRange>[2:0]</bitRange>
              <description>The amount of timestamp1 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp1_stable_low_power)-1</description>
            </field>
            <field>
              <name>TIMESTAMP1_STABLE_HIGH_POWER</name>
              <bitRange>[6:4]</bitRange>
              <description>The amount of timestamp1 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp1_stable_high_power)-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_STATUS_1</name>
          <addressOffset>0x000A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>TIMESTAMP1_INPUT</name>
              <bitRange>[0:0]</bitRange>
              <description>The current value of the timestamp1 input</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP1_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>The unmasked interrupt status of the timestamp1 not empty interrupt</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP1_OVERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>The unmasked interrupt status of the timestamp1 overrun interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000010</name>
          <addressOffset>0x0010</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP2_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the timestamp2 functinality.</description>
            </field>
            <field>
              <name>TIMESTAMP2_FIFO_SIZE</name>
              <bitRange>[2:1]</bitRange>
              <description>When set to 1, the timestamp2 fifos works in 16-bit word mode. In this mode, reading the timestamp2_main property, pops an entry from the FIFO. When set to 0, the timestamp2 fifo works in byte mode. In this mode, writing the timestamp2 property pops an entry from the fifo.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_TIMESTAMP2_STABLE_POWERS</name>
          <addressOffset>0x0011</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP2_STABLE_LOW_POWER</name>
              <bitRange>[2:0]</bitRange>
              <description>The amount of timestamp2 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp2_stable_low_power)-1</description>
            </field>
            <field>
              <name>TIMESTAMP2_STABLE_HIGH_POWER</name>
              <bitRange>[6:4]</bitRange>
              <description>The amount of timestamp2 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp2_stable_high_power)-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_STATUS_2</name>
          <addressOffset>0x0012</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>TIMESTAMP2_INPUT</name>
              <bitRange>[0:0]</bitRange>
              <description>The current value of the timestamp2 input</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP2_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>The unmasked interrupt status of the timestamp2 not empty interrupt</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP2_OVERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>The unmasked interrupt status of the timestamp2 overrun interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000018</name>
          <addressOffset>0x0018</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP3_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the timestamp3 functinality.</description>
            </field>
            <field>
              <name>TIMESTAMP3_FIFO_SIZE</name>
              <bitRange>[2:1]</bitRange>
              <description>When set to 1, the timestamp3 fifos works in 16-bit word mode. In this mode, reading the timestamp3_main property, pops an entry from the FIFO. When set to 0, the timestamp3 fifo works in byte mode. In this mode, writing the timestamp3 property pops an entry from the fifo.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_TIMESTAMP3_STABLE_POWERS</name>
          <addressOffset>0x0019</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>TIMESTAMP3_STABLE_LOW_POWER</name>
              <bitRange>[2:0]</bitRange>
              <description>The amount of timestamp3 input signal processing clock cycles that the input signal has to be low before the processed signal becomes low is (2**timestamp3_stable_low_power)-1</description>
            </field>
            <field>
              <name>TIMESTAMP3_STABLE_HIGH_POWER</name>
              <bitRange>[6:4]</bitRange>
              <description>The amount of timestamp3 input signal processing clock cycles that the input signal has to be high before the processed signal becomes high is (2**timestamp3_stable_high_power)-1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_STATUS_3</name>
          <addressOffset>0x001A</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>TIMESTAMP3_INPUT</name>
              <bitRange>[0:0]</bitRange>
              <description>The current value of the timestamp3 input</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP3_NOT_EMPTY_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>The unmasked interrupt status of the timestamp3 not empty interrupt</description>
            </field>
            <field>
              <name>UNMASKED_TIMESTAMP3_OVERRUN_INTERRUPT</name>
              <bitRange>[2:2]</bitRange>
              <description>The unmasked interrupt status of the timestamp3 overrun interrupt</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000020</name>
          <addressOffset>0x0020</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM0_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm0</description>
            </field>
            <field>
              <name>PWM0_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm0</description>
            </field>
            <field>
              <name>PWM0_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm0</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_0</name>
          <addressOffset>0x0021</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM0_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm0.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000022</name>
          <addressOffset>0x0022</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM0_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm0</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM0_INTERRUPTS</name>
          <addressOffset>0x0024</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM0_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm0</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000028</name>
          <addressOffset>0x0028</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM1_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm1</description>
            </field>
            <field>
              <name>PWM1_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm1</description>
            </field>
            <field>
              <name>PWM1_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_1</name>
          <addressOffset>0x0029</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM1_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm1.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X0000002A</name>
          <addressOffset>0x002A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM1_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM1_INTERRUPTS</name>
          <addressOffset>0x002C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM1_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm1</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000030</name>
          <addressOffset>0x0030</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM2_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm2</description>
            </field>
            <field>
              <name>PWM2_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm2</description>
            </field>
            <field>
              <name>PWM2_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm2</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_2</name>
          <addressOffset>0x0031</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM2_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm2.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000032</name>
          <addressOffset>0x0032</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM2_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm2</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM2_INTERRUPTS</name>
          <addressOffset>0x0034</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM2_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm2</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000038</name>
          <addressOffset>0x0038</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM3_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm3</description>
            </field>
            <field>
              <name>PWM3_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm3</description>
            </field>
            <field>
              <name>PWM3_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm3</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_3</name>
          <addressOffset>0x0039</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM3_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm3.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X0000003A</name>
          <addressOffset>0x003A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM3_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm3</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM3_INTERRUPTS</name>
          <addressOffset>0x003C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM3_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm3</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000040</name>
          <addressOffset>0x0040</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM4_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm4</description>
            </field>
            <field>
              <name>PWM4_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm4</description>
            </field>
            <field>
              <name>PWM4_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm4</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_4</name>
          <addressOffset>0x0041</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM4_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm4.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000042</name>
          <addressOffset>0x0042</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM4_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm4</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM4_INTERRUPTS</name>
          <addressOffset>0x0044</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM4_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm4</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000048</name>
          <addressOffset>0x0048</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM5_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm5</description>
            </field>
            <field>
              <name>PWM5_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm5</description>
            </field>
            <field>
              <name>PWM5_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm5</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_5</name>
          <addressOffset>0x0049</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM5_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm5.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X0000004A</name>
          <addressOffset>0x004A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM5_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm5</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM5_INTERRUPTS</name>
          <addressOffset>0x004C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM5_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm5</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000050</name>
          <addressOffset>0x0050</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM6_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm6</description>
            </field>
            <field>
              <name>PWM6_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm6</description>
            </field>
            <field>
              <name>PWM6_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm6</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_6</name>
          <addressOffset>0x0051</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM6_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm6.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000052</name>
          <addressOffset>0x0052</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM6_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm6</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM6_INTERRUPTS</name>
          <addressOffset>0x0054</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM6_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm6</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000058</name>
          <addressOffset>0x0058</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM7_UP_DOWN_ENABLE</name>
              <bitRange>[0:0]</bitRange>
              <description>Enables the up/down mode of pwm7</description>
            </field>
            <field>
              <name>PWM7_OUTPUT_DRIVE</name>
              <bitRange>[1:1]</bitRange>
              <description>Sets the drive type for the output of pwm7</description>
            </field>
            <field>
              <name>PWM7_OUTPUT_INVERT</name>
              <bitRange>[2:2]</bitRange>
              <description>Inverts the output of pwm7</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAPS_7</name>
          <addressOffset>0x0059</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWM7_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[0:0]</bitRange>
              <description>When set to 1, a wrap of the carrier counter will trigger an update of the threshold of pwm7.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X0000005A</name>
          <addressOffset>0x005A</addressOffset>
          <size>16</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>PWM7_THRESHOLD</name>
              <bitRange>[15:0]</bitRange>
              <description>The current value of the threshold of pwm7</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_UNMASKED_PWM7_INTERRUPTS</name>
          <addressOffset>0x005C</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_PWM7_THRESHOLD_MATCH_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the threshold match interrupt of pwm7</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_CONFIG</name>
          <addressOffset>0x0060</addressOffset>
          <size>16</size>
          <resetValue>0x00000333</resetValue>
          <access>read-write</access>
          <fields>
            <field>
              <name>MAIN_TMR</name>
              <bitRange>[2:0]</bitRange>
              <description>timer counter value to use as main counter value (16 bit)</description>
            </field>
            <field>
              <name>CARRIER_TMR</name>
              <bitRange>[6:4]</bitRange>
              <description>timer counter value to use as carrier counter value, only lower 7 bits are used</description>
            </field>
            <field>
              <name>TIMESTAMP_TMR</name>
              <bitRange>[10:8]</bitRange>
              <description>timer wrap to use as trigger to check the timestamp input value for the timestamp stable logic</description>
            </field>
            <field>
              <name>NEXT_THRESHOLD_FIFO_SIZE</name>
              <bitRange>[12:12]</bitRange>
              <description>When set to 1, the next threshold fifo works in 16-bit word mode. In this mode, writing the next_threshold property, pushes an entry in the FIFO. When set to 0, the next threshold fifo works in byte mode. In this mode, writing the next_threshold_0 property pushes an entry in the fifo.</description>
            </field>
            <field>
              <name>AUTO_SHIFT_THRESHOLD_UPDATE_ON_CARRIER_COUNTER_WRAP</name>
              <bitRange>[13:13]</bitRange>
              <description>Automatically perform a logical shift on the &amp;apos;threshold update on carrier counter wrap&amp;apos; value, on each carrier counter wrap.</description>
            </field>
          </fields>
        </register>

        <register>
          <name>PWMS_0X00000064</name>
          <addressOffset>0x0064</addressOffset>
          <size>8</size>
          <resetValue>0x00000000</resetValue>
          <access>read-only</access>
          <fields>
            <field>
              <name>UNMASKED_NEXT_THRESHOLD_UNDERRUN_INTERRUPT</name>
              <bitRange>[0:0]</bitRange>
              <description>The unmasked interrupt status of the next threshold underrun interrupt</description>
            </field>
            <field>
              <name>UNMASKED_NEXT_THRESHOLD_NOT_FULL_INTERRUPT</name>
              <bitRange>[1:1]</bitRange>
              <description>The unmasked interrupt status of the next threshold not full interrupt</description>
            </field>
          </fields>
        </register>

      </registers>
    </peripheral>

  </peripherals>
</device>
